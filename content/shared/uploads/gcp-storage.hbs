---
name: gcp-storage-upload
description: Google Cloud Storage file upload with signed URLs and resumable uploads
dependencies:
  - "@google-cloud/storage@^7.17.0"
files:
  - name: libs/uploads/gcp-storage.ts
---
import { Storage, GetSignedUrlConfig } from '@google-cloud/storage';

/**
 * GCS client configuration
 * 
 * Authentication options:
 * 1. Set GOOGLE_APPLICATION_CREDENTIALS env var to path of service account JSON
 * 2. Pass keyFilename in Storage constructor
 * 3. Use default credentials (GCE, Cloud Run, etc.)
 */
const storage = new Storage({
  projectId: process.env.GCP_PROJECT_ID,
  // keyFilename: process.env.GCP_KEY_FILE, // Optional: path to service account JSON
});

const BUCKET_NAME = process.env.GCS_BUCKET || '';
const bucket = storage.bucket(BUCKET_NAME);

/**
 * Generate a unique file path with date-based organization
 */
const generatePath = (filename: string, folder = 'uploads'): string => {
  const ext = filename.split('.').pop() || '';
  const uniqueId = Date.now().toString(36) + Math.random().toString(36).slice(2, 10);
  const date = new Date().toISOString().split('T')[0];
  return `${folder}/${date}/${uniqueId}.${ext}`;
};

/**
 * Generate a signed URL for direct PUT upload
 * Uses V4 signing (recommended)
 * 
 * @example
 * // Server: Generate URL
 * const { uploadUrl, path } = await getSignedUploadUrl('image.png', 'image/png');
 * 
 * // Client: Upload file
 * await fetch(uploadUrl, { method: 'PUT', body: file, headers: { 'Content-Type': 'image/png' } });
 */
export const getSignedUploadUrl = async (
  filename: string,
  contentType: string,
  options: {
    expiresIn?: number; // minutes, default: 15
    folder?: string;
  } = {}
): Promise<{ uploadUrl: string; path: string; publicUrl: string }> => {
  const { expiresIn = 15, folder = 'uploads' } = options;
  const path = generatePath(filename, folder);
  const file = bucket.file(path);

  const config: GetSignedUrlConfig = {
    version: 'v4',
    action: 'write',
    expires: Date.now() + expiresIn * 60 * 1000,
    contentType,
  };

  const [uploadUrl] = await file.getSignedUrl(config);
  const publicUrl = `https://storage.googleapis.com/${BUCKET_NAME}/${path}`;

  return { uploadUrl, path, publicUrl };
};

/**
 * Generate a resumable upload URL for large files
 * Supports chunked uploads and resume on failure
 * 
 * @example
 * // Server: Generate resumable URL
 * const { uploadUrl, path } = await getResumableUploadUrl('video.mp4', 'video/mp4');
 * 
 * // Client: Use resumable upload protocol
 * // First PUT to uploadUrl with Content-Length: 0 to get session URI
 * // Then PUT chunks to the session URI
 */
export const getResumableUploadUrl = async (
  filename: string,
  contentType: string,
  options: {
    folder?: string;
    metadata?: Record<string, string>;
  } = {}
): Promise<{ uploadUrl: string; path: string; publicUrl: string }> => {
  const { folder = 'uploads', metadata = {} } = options;
  const path = generatePath(filename, folder);
  const file = bucket.file(path);

  const [uploadUrl] = await file.createResumableUpload({
    metadata: {
      contentType,
      metadata,
    },
  });

  const publicUrl = `https://storage.googleapis.com/${BUCKET_NAME}/${path}`;

  return { uploadUrl, path, publicUrl };
};

/**
 * Generate a signed download URL for private files
 */
export const getSignedDownloadUrl = async (
  path: string,
  expiresIn = 60 // minutes
): Promise<string> => {
  const file = bucket.file(path);

  const config: GetSignedUrlConfig = {
    version: 'v4',
    action: 'read',
    expires: Date.now() + expiresIn * 60 * 1000,
  };

  const [url] = await file.getSignedUrl(config);
  return url;
};

/**
 * Delete a file from GCS
 */
export const deleteFile = async (path: string): Promise<void> => {
  await bucket.file(path).delete();
};

/**
 * Check if a file exists
 */
export const fileExists = async (path: string): Promise<boolean> => {
  const [exists] = await bucket.file(path).exists();
  return exists;
};

/**
 * Get file metadata
 */
export const getFileMetadata = async (path: string) => {
  const [metadata] = await bucket.file(path).getMetadata();

  return {
    contentType: metadata.contentType,
    size: metadata.size,
    updated: metadata.updated,
    md5Hash: metadata.md5Hash,
    crc32c: metadata.crc32c,
  };
};

/**
 * Upload a file buffer directly (server-side upload)
 */
export const uploadFile = async (
  buffer: Buffer,
  filename: string,
  contentType: string,
  folder = 'uploads'
): Promise<{ path: string; url: string }> => {
  const path = generatePath(filename, folder);
  const file = bucket.file(path);

  await file.save(buffer, {
    contentType,
    resumable: false,
  });

  const url = `https://storage.googleapis.com/${BUCKET_NAME}/${path}`;
  return { path, url };
};

/**
 * Make a file publicly accessible
 */
export const makePublic = async (path: string): Promise<string> => {
  await bucket.file(path).makePublic();
  return `https://storage.googleapis.com/${BUCKET_NAME}/${path}`;
};
