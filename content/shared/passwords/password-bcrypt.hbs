---
name: password-bcrypt
description: Secure password hashing using Bcrypt
dependencies:
  - bcrypt@^6.0.0
devDependencies:
  - "@types/bcrypt@^5.0.2"
files:
  - name: utils/password.ts
---
import bcrypt from 'bcrypt';

/**
 * Salt rounds configuration:
 * - 10: ~100ms (minimum acceptable)
 * - 12: ~300ms (recommended for most applications)
 * - 14: ~1s (high security, may impact UX)
 * 
 * Increase this value as hardware improves.
 * Each increment doubles the computation time.
 */
const SALT_ROUNDS = 12;

/**
 * Hash a password using bcrypt
 * @param password - Plain text password to hash
 * @returns Hashed password string
 */
export const encryptPassword = async (password: string): Promise<string> => {
  if (!password.length) {
    throw new Error('Password cannot be empty');
  }

  // Bcrypt has a 72-byte limit on password input
  if (Buffer.byteLength(password, 'utf8') > 72) {
    throw new Error('Password exceeds maximum length of 72 bytes');
  }

  return bcrypt.hash(password, SALT_ROUNDS);
};

/**
 * Verify a password against its hash
 * Uses constant-time comparison internally
 * @param password - Plain text password to verify
 * @param hash - Previously hashed password
 * @returns True if password matches
 */
export const verifyPassword = async (password: string, hash: string): Promise<boolean> => {
  if (!password || !hash) {
    return false;
  }
  try {
    return await bcrypt.compare(password, hash);
  } catch {
    // Invalid hash format or other error
    return false;
  }
};

/**
 * Get the number of salt rounds used in an existing hash
 * Useful for determining if a password needs rehashing
 * @param hash - Existing bcrypt hash
 * @returns Number of salt rounds
 */
export const getSaltRounds = (hash: string): number => {
  return bcrypt.getRounds(hash);
};

/**
 * Check if a hash needs to be rehashed (e.g., after increasing salt rounds)
 * @param hash - Existing password hash
 * @returns True if the hash uses fewer rounds than current config
 */
export const needsRehash = (hash: string): boolean => {
  try {
    return getSaltRounds(hash) < SALT_ROUNDS;
  } catch {
    return true; // Invalid hash, should be rehashed
  }
};
