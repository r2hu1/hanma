{
  "hono-swagger": "import { swaggerUI } from \"@hono/swagger-ui\";\nimport { Hono } from \"hono\";\n\n/**\n * OpenAPI specification for your API\n */\nexport const openApiSpec = {\n  openapi: \"3.0.0\",\n  info: {\n    title: \"Hono API\",\n    version: \"1.0.0\",\n    description: \"API documentation for your Hono application\",\n  },\n  servers: [\n    {\n      url: process.env.API_URL || \"http://localhost:3000\",\n      description: \"API Server\",\n    },\n  ],\n  paths: {\n    \"/health\": {\n      get: {\n        summary: \"Health check\",\n        responses: {\n          \"200\": {\n            description: \"OK\",\n            content: {\n              \"application/json\": {\n                schema: {\n                  type: \"object\",\n                  properties: {\n                    status: { type: \"string\" },\n                    timestamp: { type: \"string\" },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n    // Add more paths here\n  },\n  components: {\n    securitySchemes: {\n      bearerAuth: {\n        type: \"http\",\n        scheme: \"bearer\",\n        bearerFormat: \"JWT\",\n      },\n    },\n  },\n};\n\n/**\n * Setup Swagger UI routes\n */\nexport const setupSwagger = (app: Hono) => {\n  // Serve OpenAPI spec as JSON\n  app.get(\"/api-docs/json\", (c) => c.json(openApiSpec));\n\n  // Serve Swagger UI\n  app.get(\n    \"/api-docs\",\n    swaggerUI({\n      url: \"/api-docs/json\",\n    })\n  );\n\n  console.log(\"[Swagger] Documentation available at /api-docs\");\n};\n",
  "hono-basic": "import { Hono } from \"hono\";\nimport { logger } from \"hono/logger\";\nimport { requestId } from \"hono/request-id\";\nimport { cors } from \"hono/cors\";\nimport { secureHeaders } from \"hono/secure-headers\";\nimport { timing } from \"hono/timing\";\nimport { serve } from \"@hono/node-server\";\nimport type { Context } from \"hono\";\n\n// Environment configuration\nconst config = {\n  port: Number(process.env.PORT) || 3000,\n  env: process.env.NODE_ENV || \"development\",\n  corsOrigins: process.env.CORS_ORIGINS?.split(\",\") || [\"*\"],\n  shutdownTimeout: Number(process.env.SHUTDOWN_TIMEOUT) || 10000,\n};\n\n// Application type with custom variables\ntype AppEnv = {\n  Variables: {\n    requestId: string;\n    startTime: number;\n  };\n};\n\nconst app = new Hono<AppEnv>();\n\n// Security and observability middleware\napp.use(\"*\", secureHeaders());\napp.use(\"*\", timing());\napp.use(\"*\", requestId());\napp.use(\"*\", logger());\napp.use(\"*\", cors({\n  origin: config.corsOrigins,\n  allowMethods: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\n  allowHeaders: [\"Content-Type\", \"Authorization\", \"X-Request-ID\"],\n  exposeHeaders: [\"X-Request-ID\", \"X-Response-Time\"],\n  maxAge: 86400,\n  credentials: true,\n}));\n\n// Request timing middleware\napp.use(\"*\", async (c, next) => {\n  c.set(\"startTime\", Date.now());\n  await next();\n});\n\n// Health check endpoint\napp.get(\"/health\", (c) => {\n  const uptime = process.uptime();\n  const memory = process.memoryUsage();\n  \n  return c.json({\n    status: \"healthy\",\n    timestamp: new Date().toISOString(),\n    runtime: \"node\",\n    version: process.version,\n    uptime: {\n      seconds: Math.floor(uptime),\n      formatted: formatUptime(uptime),\n    },\n    memory: {\n      heapUsed: formatBytes(memory.heapUsed),\n      heapTotal: formatBytes(memory.heapTotal),\n      rss: formatBytes(memory.rss),\n    },\n  });\n});\n\n// Readiness check for k8s/container orchestration\napp.get(\"/ready\", (c) => {\n  // Add your readiness checks here (DB connection, cache, etc.)\n  return c.json({ ready: true });\n});\n\n// Liveness check\napp.get(\"/live\", (c) => c.text(\"OK\"));\n\n// Example route\napp.get(\"/\", (c) => {\n  return c.json({\n    message: \"Hello from Hono!\",\n    requestId: c.get(\"requestId\"),\n    environment: config.env,\n  });\n});\n\n// 404 handler\napp.notFound((c) => {\n  return c.json(\n    {\n      success: false,\n      error: {\n        code: \"NOT_FOUND\",\n        message: `Path ${c.req.method} ${c.req.path} not found`,\n      },\n      requestId: c.get(\"requestId\"),\n    },\n    404\n  );\n});\n\n// Global error handler\napp.onError((err, c) => {\n  const requestId = c.get(\"requestId\") || \"unknown\";\n  const status = \"status\" in err ? (err.status as number) : 500;\n  \n  // Structured error logging\n  console.error(JSON.stringify({\n    level: \"error\",\n    message: err.message,\n    stack: err.stack,\n    requestId,\n    path: c.req.path,\n    method: c.req.method,\n    timestamp: new Date().toISOString(),\n  }));\n  \n  return c.json(\n    {\n      success: false,\n      error: {\n        code: status === 500 ? \"INTERNAL_ERROR\" : \"REQUEST_ERROR\",\n        message: config.env === \"production\" \n          ? \"An unexpected error occurred\" \n          : err.message,\n      },\n      requestId,\n    },\n    status\n  );\n});\n\n// Utility functions\nfunction formatUptime(seconds: number): string {\n  const days = Math.floor(seconds / 86400);\n  const hours = Math.floor((seconds % 86400) / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  return `${days}d ${hours}h ${mins}m`;\n}\n\nfunction formatBytes(bytes: number): string {\n  const units = [\"B\", \"KB\", \"MB\", \"GB\"];\n  let i = 0;\n  while (bytes >= 1024 && i < units.length - 1) {\n    bytes /= 1024;\n    i++;\n  }\n  return `${bytes.toFixed(2)} ${units[i]}`;\n}\n\n// Start server\nconst server = serve({\n  fetch: app.fetch,\n  port: config.port,\n}, (info) => {\n  console.log(JSON.stringify({\n    level: \"info\",\n    message: \"Server started\",\n    port: info.port,\n    environment: config.env,\n    timestamp: new Date().toISOString(),\n  }));\n});\n\n// Graceful shutdown\nlet isShuttingDown = false;\n\nconst shutdown = (signal: string) => {\n  if (isShuttingDown) return;\n  isShuttingDown = true;\n  \n  console.log(JSON.stringify({\n    level: \"info\",\n    message: `${signal} received, shutting down gracefully`,\n    timestamp: new Date().toISOString(),\n  }));\n  \n  server.close(() => {\n    console.log(JSON.stringify({\n      level: \"info\",\n      message: \"Server stopped\",\n      timestamp: new Date().toISOString(),\n    }));\n    process.exit(0);\n  });\n  \n  // Force shutdown after timeout\n  setTimeout(() => {\n    console.error(JSON.stringify({\n      level: \"error\",\n      message: \"Forced shutdown due to timeout\",\n      timestamp: new Date().toISOString(),\n    }));\n    process.exit(1);\n  }, config.shutdownTimeout).unref();\n};\n\nprocess.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => shutdown(\"SIGINT\"));",
  "hono-bun": "import { Hono } from \"hono\";\nimport { logger } from \"hono/logger\";\nimport { requestId } from \"hono/request-id\";\nimport { cors } from \"hono/cors\";\nimport { secureHeaders } from \"hono/secure-headers\";\nimport { timing } from \"hono/timing\";\nimport type { Context } from \"hono\";\n\n// Environment configuration\nconst config = {\n  port: Number(Bun.env.PORT) || 3000,\n  env: Bun.env.NODE_ENV || \"development\",\n  corsOrigins: Bun.env.CORS_ORIGINS?.split(\",\") || [\"*\"],\n};\n\n// Application type with custom variables\ntype AppEnv = {\n  Variables: {\n    requestId: string;\n    startTime: number;\n  };\n};\n\nconst app = new Hono<AppEnv>();\n\n// Security and observability middleware\napp.use(\"*\", secureHeaders());\napp.use(\"*\", timing());\napp.use(\"*\", requestId());\napp.use(\"*\", logger());\napp.use(\"*\", cors({\n  origin: config.corsOrigins,\n  allowMethods: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\n  allowHeaders: [\"Content-Type\", \"Authorization\", \"X-Request-ID\"],\n  exposeHeaders: [\"X-Request-ID\", \"X-Response-Time\"],\n  maxAge: 86400,\n  credentials: true,\n}));\n\n// Request timing middleware\napp.use(\"*\", async (c, next) => {\n  c.set(\"startTime\", Date.now());\n  await next();\n});\n\n// Health check endpoint\napp.get(\"/health\", (c) => {\n  const uptime = process.uptime();\n  const memory = process.memoryUsage();\n  \n  return c.json({\n    status: \"healthy\",\n    timestamp: new Date().toISOString(),\n    runtime: \"bun\",\n    version: Bun.version,\n    uptime: {\n      seconds: Math.floor(uptime),\n      formatted: formatUptime(uptime),\n    },\n    memory: {\n      heapUsed: formatBytes(memory.heapUsed),\n      heapTotal: formatBytes(memory.heapTotal),\n      rss: formatBytes(memory.rss),\n    },\n  });\n});\n\n// Readiness check for k8s/container orchestration\napp.get(\"/ready\", (c) => {\n  // Add your readiness checks here (DB connection, cache, etc.)\n  return c.json({ ready: true });\n});\n\n// Liveness check\napp.get(\"/live\", (c) => c.text(\"OK\"));\n\n// Example route\napp.get(\"/\", (c) => {\n  return c.json({\n    message: \"Hello from Bun!\",\n    requestId: c.get(\"requestId\"),\n    environment: config.env,\n  });\n});\n\n// 404 handler\napp.notFound((c) => {\n  return c.json(\n    {\n      success: false,\n      error: {\n        code: \"NOT_FOUND\",\n        message: `Path ${c.req.method} ${c.req.path} not found`,\n      },\n      requestId: c.get(\"requestId\"),\n    },\n    404\n  );\n});\n\n// Global error handler\napp.onError((err, c) => {\n  const requestId = c.get(\"requestId\") || \"unknown\";\n  const status = \"status\" in err ? (err.status as number) : 500;\n  \n  // Log error with context\n  console.error(JSON.stringify({\n    level: \"error\",\n    message: err.message,\n    stack: err.stack,\n    requestId,\n    path: c.req.path,\n    method: c.req.method,\n    timestamp: new Date().toISOString(),\n  }));\n  \n  return c.json(\n    {\n      success: false,\n      error: {\n        code: status === 500 ? \"INTERNAL_ERROR\" : \"REQUEST_ERROR\",\n        message: config.env === \"production\" \n          ? \"An unexpected error occurred\" \n          : err.message,\n      },\n      requestId,\n    },\n    status\n  );\n});\n\n// Utility functions\nfunction formatUptime(seconds: number): string {\n  const days = Math.floor(seconds / 86400);\n  const hours = Math.floor((seconds % 86400) / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  return `${days}d ${hours}h ${mins}m`;\n}\n\nfunction formatBytes(bytes: number): string {\n  const units = [\"B\", \"KB\", \"MB\", \"GB\"];\n  let i = 0;\n  while (bytes >= 1024 && i < units.length - 1) {\n    bytes /= 1024;\n    i++;\n  }\n  return `${bytes.toFixed(2)} ${units[i]}`;\n}\n\n// Start server\nconst server = Bun.serve({\n  port: config.port,\n  fetch: app.fetch,\n  error(error) {\n    console.error(\"Unhandled server error:\", error);\n    return new Response(\"Internal Server Error\", { status: 500 });\n  },\n});\n\nconsole.log(JSON.stringify({\n  level: \"info\",\n  message: \"Server started\",\n  port: server.port,\n  environment: config.env,\n  timestamp: new Date().toISOString(),\n}));\n\n// Graceful shutdown\nconst shutdown = (signal: string) => {\n  console.log(JSON.stringify({\n    level: \"info\",\n    message: `${signal} received, shutting down gracefully`,\n    timestamp: new Date().toISOString(),\n  }));\n  \n  server.stop();\n  \n  // Allow pending requests to complete\n  setTimeout(() => {\n    console.log(JSON.stringify({\n      level: \"info\",\n      message: \"Server stopped\",\n      timestamp: new Date().toISOString(),\n    }));\n    process.exit(0);\n  }, 5000);\n};\n\nprocess.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => shutdown(\"SIGINT\"));\n",
  "hono-cloudflare-workers": "import { Hono } from \"hono\";\nimport { logger } from \"hono/logger\";\nimport { requestId } from \"hono/request-id\";\nimport { cors } from \"hono/cors\";\nimport { secureHeaders } from \"hono/secure-headers\";\nimport { timing } from \"hono/timing\";\nimport { cache } from \"hono/cache\";\n\n// Type definitions for Cloudflare bindings\ntype Bindings = {\n  ENVIRONMENT: string;\n  CORS_ORIGINS: string;\n  // Add your bindings here:\n  // MY_KV: KVNamespace;\n  // MY_DB: D1Database;\n  // MY_R2: R2Bucket;\n};\n\ntype Variables = {\n  requestId: string;\n};\n\nconst app = new Hono<{ Bindings: Bindings; Variables: Variables }>();\n\n// Security middleware\napp.use(\"*\", secureHeaders());\napp.use(\"*\", timing());\napp.use(\"*\", requestId());\napp.use(\"*\", logger());\n\n// Dynamic CORS based on environment binding\napp.use(\"*\", async (c, next) => {\n  const origins = c.env.CORS_ORIGINS?.split(\",\") || [\"*\"];\n  return cors({\n    origin: origins,\n    allowMethods: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\n    allowHeaders: [\"Content-Type\", \"Authorization\", \"X-Request-ID\"],\n    exposeHeaders: [\"X-Request-ID\", \"X-Response-Time\"],\n    maxAge: 86400,\n    credentials: true,\n  })(c, next);\n});\n\n// Cache static responses at edge\napp.get(\n  \"/health\",\n  cache({\n    cacheName: \"health-check\",\n    cacheControl: \"public, max-age=60\",\n  }),\n  (c) => {\n    const cf = c.req.raw.cf;\n    \n    return c.json({\n      status: \"healthy\",\n      timestamp: new Date().toISOString(),\n      runtime: \"cloudflare-workers\",\n      edge: {\n        colo: cf?.colo || \"unknown\",\n        country: cf?.country || \"unknown\",\n        city: cf?.city || \"unknown\",\n        region: cf?.region || \"unknown\",\n      },\n      environment: c.env.ENVIRONMENT || \"development\",\n    });\n  }\n);\n\n// Example route with request context\napp.get(\"/\", (c) => {\n  const cf = c.req.raw.cf;\n  \n  return c.json({\n    message: \"Hello from Cloudflare Workers!\",\n    requestId: c.get(\"requestId\"),\n    edge: {\n      colo: cf?.colo,\n      country: cf?.country,\n    },\n  });\n});\n\n// Example: KV operations (uncomment when binding is configured)\n// app.get(\"/kv/:key\", async (c) => {\n//   const key = c.req.param(\"key\");\n//   const value = await c.env.MY_KV.get(key);\n//   \n//   if (!value) {\n//     return c.json({ \n//       success: false, \n//       error: { code: \"NOT_FOUND\", message: \"Key not found\" } \n//     }, 404);\n//   }\n//   \n//   return c.json({ key, value });\n// });\n\n// app.put(\"/kv/:key\", async (c) => {\n//   const key = c.req.param(\"key\");\n//   const body = await c.req.json<{ value: string; ttl?: number }>();\n//   \n//   await c.env.MY_KV.put(key, body.value, {\n//     expirationTtl: body.ttl || 3600,\n//   });\n//   \n//   return c.json({ success: true, key });\n// });\n\n// 404 handler\napp.notFound((c) => {\n  return c.json(\n    {\n      success: false,\n      error: {\n        code: \"NOT_FOUND\",\n        message: `Path ${c.req.method} ${c.req.path} not found`,\n      },\n      requestId: c.get(\"requestId\"),\n    },\n    404\n  );\n});\n\n// Global error handler\napp.onError((err, c) => {\n  const requestId = c.get(\"requestId\") || \"unknown\";\n  const status = \"status\" in err ? (err.status as number) : 500;\n  const isProduction = c.env.ENVIRONMENT === \"production\";\n  \n  // Log to console (visible in Workers logs)\n  console.error(JSON.stringify({\n    level: \"error\",\n    message: err.message,\n    requestId,\n    path: c.req.path,\n    method: c.req.method,\n    colo: c.req.raw.cf?.colo,\n    timestamp: new Date().toISOString(),\n  }));\n  \n  return c.json(\n    {\n      success: false,\n      error: {\n        code: status === 500 ? \"INTERNAL_ERROR\" : \"REQUEST_ERROR\",\n        message: isProduction ? \"An unexpected error occurred\" : err.message,\n      },\n      requestId,\n    },\n    status\n  );\n});\n\nexport default app;\n",
  "hono-deno": "import { Hono } from \"https://deno.land/x/hono/mod.ts\";\nimport { logger } from \"https://deno.land/x/hono/middleware.ts\";\nimport { requestId } from \"https://deno.land/x/hono/middleware.ts\";\nimport { cors } from \"https://deno.land/x/hono/middleware.ts\";\nimport { secureHeaders } from \"https://deno.land/x/hono/middleware.ts\";\nimport { timing } from \"https://deno.land/x/hono/middleware.ts\";\n\n// Environment configuration\nconst config = {\n  port: Number(Deno.env.get(\"PORT\")) || 3000,\n  env: Deno.env.get(\"DENO_ENV\") || \"development\",\n  corsOrigins: Deno.env.get(\"CORS_ORIGINS\")?.split(\",\") || [\"*\"],\n};\n\n// Application type\ntype AppEnv = {\n  Variables: {\n    requestId: string;\n    startTime: number;\n  };\n};\n\nconst app = new Hono<AppEnv>();\n\n// Security and observability middleware\napp.use(\"*\", secureHeaders());\napp.use(\"*\", timing());\napp.use(\"*\", requestId());\napp.use(\"*\", logger());\napp.use(\"*\", cors({\n  origin: config.corsOrigins,\n  allowMethods: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\n  allowHeaders: [\"Content-Type\", \"Authorization\", \"X-Request-ID\"],\n  exposeHeaders: [\"X-Request-ID\", \"X-Response-Time\"],\n  maxAge: 86400,\n  credentials: true,\n}));\n\n// Request timing\napp.use(\"*\", async (c, next) => {\n  c.set(\"startTime\", Date.now());\n  await next();\n});\n\n// Health check endpoint\napp.get(\"/health\", (c) => {\n  const memory = Deno.memoryUsage();\n  \n  return c.json({\n    status: \"healthy\",\n    timestamp: new Date().toISOString(),\n    runtime: \"deno\",\n    version: Deno.version.deno,\n    typescript: Deno.version.typescript,\n    v8: Deno.version.v8,\n    memory: {\n      heapUsed: formatBytes(memory.heapUsed),\n      heapTotal: formatBytes(memory.heapTotal),\n      rss: formatBytes(memory.rss),\n    },\n  });\n});\n\n// Readiness check\napp.get(\"/ready\", (c) => {\n  return c.json({ ready: true });\n});\n\n// Liveness check\napp.get(\"/live\", (c) => c.text(\"OK\"));\n\n// Example route\napp.get(\"/\", (c) => {\n  return c.json({\n    message: \"Hello from Deno!\",\n    requestId: c.get(\"requestId\"),\n    environment: config.env,\n  });\n});\n\n// 404 handler\napp.notFound((c) => {\n  return c.json(\n    {\n      success: false,\n      error: {\n        code: \"NOT_FOUND\",\n        message: `Path ${c.req.method} ${c.req.path} not found`,\n      },\n      requestId: c.get(\"requestId\"),\n    },\n    404\n  );\n});\n\n// Global error handler\napp.onError((err, c) => {\n  const requestId = c.get(\"requestId\") || \"unknown\";\n  const status = \"status\" in err ? (err.status as number) : 500;\n  \n  // Structured logging\n  console.error(JSON.stringify({\n    level: \"error\",\n    message: err.message,\n    stack: err.stack,\n    requestId,\n    path: c.req.path,\n    method: c.req.method,\n    timestamp: new Date().toISOString(),\n  }));\n  \n  return c.json(\n    {\n      success: false,\n      error: {\n        code: status === 500 ? \"INTERNAL_ERROR\" : \"REQUEST_ERROR\",\n        message: config.env === \"production\" \n          ? \"An unexpected error occurred\" \n          : err.message,\n      },\n      requestId,\n    },\n    status\n  );\n});\n\n// Utility function\nfunction formatBytes(bytes: number): string {\n  const units = [\"B\", \"KB\", \"MB\", \"GB\"];\n  let i = 0;\n  while (bytes >= 1024 && i < units.length - 1) {\n    bytes /= 1024;\n    i++;\n  }\n  return `${bytes.toFixed(2)} ${units[i]}`;\n}\n\n// Abort controller for graceful shutdown\nconst abortController = new AbortController();\n\n// Start server\nDeno.serve(\n  {\n    port: config.port,\n    signal: abortController.signal,\n    onListen: ({ port, hostname }) => {\n      console.log(JSON.stringify({\n        level: \"info\",\n        message: \"Server started\",\n        hostname,\n        port,\n        environment: config.env,\n        timestamp: new Date().toISOString(),\n      }));\n    },\n  },\n  app.fetch\n);\n\n// Graceful shutdown\nconst shutdown = (signal: string) => {\n  console.log(JSON.stringify({\n    level: \"info\",\n    message: `${signal} received, shutting down gracefully`,\n    timestamp: new Date().toISOString(),\n  }));\n  \n  abortController.abort();\n  \n  setTimeout(() => {\n    console.log(JSON.stringify({\n      level: \"info\",\n      message: \"Server stopped\",\n      timestamp: new Date().toISOString(),\n    }));\n    Deno.exit(0);\n  }, 5000);\n};\n\nDeno.addSignalListener(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\nDeno.addSignalListener(\"SIGINT\", () => shutdown(\"SIGINT\"));\n",
  "hono-lambda": "import { Hono } from \"hono\";\nimport { handle, type LambdaEvent, type LambdaContext } from \"@hono/aws-lambda\";\nimport { logger } from \"hono/logger\";\nimport { requestId } from \"hono/request-id\";\nimport { cors } from \"hono/cors\";\nimport { secureHeaders } from \"hono/secure-headers\";\nimport { timing } from \"hono/timing\";\n\n// Environment configuration\nconst config = {\n  env: process.env.NODE_ENV || \"development\",\n  corsOrigins: process.env.CORS_ORIGINS?.split(\",\") || [\"*\"],\n  region: process.env.AWS_REGION || \"unknown\",\n  functionName: process.env.AWS_LAMBDA_FUNCTION_NAME || \"unknown\",\n};\n\n// Cold start tracking\nlet coldStart = true;\n\n// Application type\ntype AppEnv = {\n  Variables: {\n    requestId: string;\n    lambdaContext: LambdaContext;\n  };\n};\n\nconst app = new Hono<AppEnv>();\n\n// Security and observability middleware\napp.use(\"*\", secureHeaders());\napp.use(\"*\", timing());\napp.use(\"*\", requestId());\napp.use(\"*\", logger());\napp.use(\"*\", cors({\n  origin: config.corsOrigins,\n  allowMethods: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\n  allowHeaders: [\"Content-Type\", \"Authorization\", \"X-Request-ID\"],\n  exposeHeaders: [\"X-Request-ID\", \"X-Response-Time\"],\n  maxAge: 86400,\n  credentials: true,\n}));\n\n// Health check endpoint\napp.get(\"/health\", (c) => {\n  const isColdStart = coldStart;\n  coldStart = false;\n  \n  return c.json({\n    status: \"healthy\",\n    timestamp: new Date().toISOString(),\n    runtime: \"aws-lambda\",\n    region: config.region,\n    functionName: config.functionName,\n    coldStart: isColdStart,\n    memoryLimit: `${process.env.AWS_LAMBDA_FUNCTION_MEMORY_SIZE}MB`,\n  });\n});\n\n// Example route\napp.get(\"/\", (c) => {\n  return c.json({\n    message: \"Hello from AWS Lambda!\",\n    requestId: c.get(\"requestId\"),\n    environment: config.env,\n  });\n});\n\n// Example with path parameters and validation\napp.get(\"/users/:id\", (c) => {\n  const id = c.req.param(\"id\");\n  \n  // Basic validation\n  if (!/^\\d+$/.test(id)) {\n    return c.json(\n      {\n        success: false,\n        error: {\n          code: \"VALIDATION_ERROR\",\n          message: \"User ID must be a number\",\n        },\n      },\n      400\n    );\n  }\n  \n  return c.json({\n    user: {\n      id: Number(id),\n      name: \"Example User\",\n    },\n    requestId: c.get(\"requestId\"),\n  });\n});\n\n// 404 handler\napp.notFound((c) => {\n  return c.json(\n    {\n      success: false,\n      error: {\n        code: \"NOT_FOUND\",\n        message: `Path ${c.req.method} ${c.req.path} not found`,\n      },\n      requestId: c.get(\"requestId\"),\n    },\n    404\n  );\n});\n\n// Global error handler\napp.onError((err, c) => {\n  const requestId = c.get(\"requestId\") || \"unknown\";\n  const status = \"status\" in err ? (err.status as number) : 500;\n  \n  // Structured logging for CloudWatch\n  console.error(JSON.stringify({\n    level: \"error\",\n    message: err.message,\n    stack: err.stack,\n    requestId,\n    path: c.req.path,\n    method: c.req.method,\n    functionName: config.functionName,\n    region: config.region,\n    timestamp: new Date().toISOString(),\n  }));\n  \n  return c.json(\n    {\n      success: false,\n      error: {\n        code: status === 500 ? \"INTERNAL_ERROR\" : \"REQUEST_ERROR\",\n        message: config.env === \"production\" \n          ? \"An unexpected error occurred\" \n          : err.message,\n      },\n      requestId,\n    },\n    status\n  );\n});\n\n// Lambda handler with cold start reset\nexport const handler = async (event: LambdaEvent, context: LambdaContext) => {\n  // Track cold start per invocation\n  const isCold = coldStart;\n  coldStart = false;\n  \n  // Add cold start header\n  const response = await handle(app)(event, context);\n  \n  // Log invocation metrics\n  console.log(JSON.stringify({\n    level: \"info\",\n    type: \"invocation\",\n    path: event.path || event.rawPath,\n    method: event.httpMethod || event.requestContext?.http?.method,\n    coldStart: isCold,\n    remainingTimeMs: context.getRemainingTimeInMillis(),\n    requestId: context.awsRequestId,\n    timestamp: new Date().toISOString(),\n  }));\n  \n  return response;\n};\n",
  "hono-vercel": "import { Hono } from \"hono\";\nimport { handle } from \"hono/vercel\";\nimport { logger } from \"hono/logger\";\nimport { requestId } from \"hono/request-id\";\nimport { cors } from \"hono/cors\";\nimport { secureHeaders } from \"hono/secure-headers\";\nimport { timing } from \"hono/timing\";\nimport { cache } from \"hono/cache\";\n\nexport const config = {\n  runtime: \"edge\",\n};\n\n// Environment configuration\nconst envConfig = {\n  env: process.env.NODE_ENV || \"development\",\n  corsOrigins: process.env.CORS_ORIGINS?.split(\",\") || [\"*\"],\n  region: process.env.VERCEL_REGION || \"unknown\",\n  deployment: process.env.VERCEL_URL || \"localhost\",\n};\n\n// Application type\ntype AppEnv = {\n  Variables: {\n    requestId: string;\n  };\n};\n\nconst app = new Hono<AppEnv>().basePath(\"/api\");\n\n// Security and observability middleware\napp.use(\"*\", secureHeaders());\napp.use(\"*\", timing());\napp.use(\"*\", requestId());\napp.use(\"*\", logger());\napp.use(\"*\", cors({\n  origin: envConfig.corsOrigins,\n  allowMethods: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\n  allowHeaders: [\"Content-Type\", \"Authorization\", \"X-Request-ID\"],\n  exposeHeaders: [\"X-Request-ID\", \"X-Response-Time\"],\n  maxAge: 86400,\n  credentials: true,\n}));\n\n// Cached health check\napp.get(\n  \"/health\",\n  cache({\n    cacheName: \"health-check\",\n    cacheControl: \"public, max-age=60\",\n  }),\n  (c) => {\n    return c.json({\n      status: \"healthy\",\n      timestamp: new Date().toISOString(),\n      runtime: \"vercel-edge\",\n      region: envConfig.region,\n      deployment: envConfig.deployment,\n      environment: envConfig.env,\n    });\n  }\n);\n\n// Example route\napp.get(\"/\", (c) => {\n  return c.json({\n    message: \"Hello from Vercel Edge!\",\n    requestId: c.get(\"requestId\"),\n    region: envConfig.region,\n    environment: envConfig.env,\n  });\n});\n\n// Example with caching\napp.get(\n  \"/cached\",\n  cache({\n    cacheName: \"cached-response\",\n    cacheControl: \"public, max-age=300, s-maxage=600, stale-while-revalidate=86400\",\n  }),\n  (c) => {\n    return c.json({\n      data: \"This response is cached at the edge\",\n      generatedAt: new Date().toISOString(),\n      requestId: c.get(\"requestId\"),\n    });\n  }\n);\n\n// 404 handler\napp.notFound((c) => {\n  return c.json(\n    {\n      success: false,\n      error: {\n        code: \"NOT_FOUND\",\n        message: `Path ${c.req.method} ${c.req.path} not found`,\n      },\n      requestId: c.get(\"requestId\"),\n    },\n    404\n  );\n});\n\n// Global error handler\napp.onError((err, c) => {\n  const requestId = c.get(\"requestId\") || \"unknown\";\n  const status = \"status\" in err ? (err.status as number) : 500;\n  const isProduction = envConfig.env === \"production\";\n  \n  // Log error (visible in Vercel logs)\n  console.error(JSON.stringify({\n    level: \"error\",\n    message: err.message,\n    requestId,\n    path: c.req.path,\n    method: c.req.method,\n    region: envConfig.region,\n    timestamp: new Date().toISOString(),\n  }));\n  \n  return c.json(\n    {\n      success: false,\n      error: {\n        code: status === 500 ? \"INTERNAL_ERROR\" : \"REQUEST_ERROR\",\n        message: isProduction ? \"An unexpected error occurred\" : err.message,\n      },\n      requestId,\n    },\n    status\n  );\n});\n\nexport default handle(app);\n",
  "hono-cors": "import { cors } from \"hono/cors\";\nimport type { CorsOptions } from \"hono/cors\";\n\n/**\n * Parses environment variables to get allowed origins, methods, and headers.\n * Set these in your .env file:\n * - CORS_ORIGINS=https://example.com,https://app.example.com\n * - CORS_METHODS=GET,POST,PUT,DELETE,OPTIONS\n * - CORS_HEADERS=Content-Type,Authorization\n */\nconst getEnvConfig = () => {\n  const allowedOrigins = (process.env.CORS_ORIGINS ?? \"\")\n    .split(\",\")\n    .map((o) => o.trim())\n    .filter((o) => o.length > 0);\n\n  const allowedMethods = (process.env.CORS_METHODS ?? \"GET,POST,PUT,DELETE,OPTIONS\")\n    .split(\",\")\n    .map((m) => m.trim())\n    .filter((m) => m.length > 0);\n\n  const allowedHeaders = (process.env.CORS_HEADERS ?? \"Content-Type,Authorization\")\n    .split(\",\")\n    .map((h) => h.trim())\n    .filter((h) => h.length > 0);\n\n  return { allowedOrigins, allowedMethods, allowedHeaders };\n};\n\nexport const { allowedOrigins, allowedMethods, allowedHeaders } = getEnvConfig();\n\n/**\n * Creates CORS options based on environment or provided overrides.\n */\nexport const createCorsOptions = (\n  overrides?: Partial<CorsOptions> & {\n    origins?: string[];\n    methods?: string[];\n    headers?: string[];\n  }\n): CorsOptions => {\n  const origins = overrides?.origins ?? allowedOrigins;\n  const methods = overrides?.methods ?? allowedMethods;\n  const headers = overrides?.headers ?? allowedHeaders;\n\n  return {\n    origin: (origin) => {\n      // Allow requests with no origin (mobile apps, curl, same-origin)\n      if (!origin) return origin;\n\n      // If no origins configured, allow all (development mode)\n      if (origins.length === 0) return origin;\n\n      // Check if origin is in allowed list\n      return origins.includes(origin) ? origin : origins[0];\n    },\n    allowMethods: methods,\n    allowHeaders: headers,\n    exposeHeaders: [\"Content-Length\", \"X-Request-Id\"],\n    maxAge: 600,\n    credentials: true,\n    ...overrides,\n  };\n};\n\n/**\n * Validate CORS configuration on startup\n */\nexport const validateCorsConfig = (): boolean => {\n  if (allowedOrigins.length === 0) {\n    console.warn(\n      \"[CORS] No CORS_ORIGINS configured. All origins will be allowed (development mode).\"\n    );\n    return false;\n  }\n  console.log(`[CORS] Allowed origins: ${allowedOrigins.join(\", \")}`);\n  return true;\n};\n\n/**\n * Pre-configured CORS middleware using environment variables\n */\nexport const corsMiddleware = cors(createCorsOptions());\n\n/**\n * Development CORS (allows all origins)\n */\nexport const devCorsMiddleware = cors({\n  origin: \"*\",\n  allowMethods: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"],\n  allowHeaders: [\"Content-Type\", \"Authorization\"],\n  credentials: true,\n});\n\n/**\n * Get appropriate CORS middleware based on environment\n */\nexport const getCorsMiddleware = () => {\n  return process.env.NODE_ENV === \"production\" ? corsMiddleware : devCorsMiddleware;\n};\n",
  "hono-error-handler": "import { HTTPException } from \"hono/http-exception\";\nimport type { ErrorHandler } from \"hono\";\n\n/**\n * Application error class for custom errors\n */\nexport class AppError extends Error {\n  constructor(\n    public message: string,\n    public statusCode: number = 500,\n    public code?: string,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = \"AppError\";\n  }\n}\n\n/**\n * Not Found error\n */\nexport class NotFoundError extends AppError {\n  constructor(resource = \"Resource\") {\n    super(`${resource} not found`, 404, \"NOT_FOUND\");\n  }\n}\n\n/**\n * Validation error\n */\nexport class ValidationError extends AppError {\n  constructor(message: string, details?: unknown) {\n    super(message, 400, \"VALIDATION_ERROR\", details);\n  }\n}\n\n/**\n * Unauthorized error\n */\nexport class UnauthorizedError extends AppError {\n  constructor(message = \"Unauthorized\") {\n    super(message, 401, \"UNAUTHORIZED\");\n  }\n}\n\n/**\n * Forbidden error\n */\nexport class ForbiddenError extends AppError {\n  constructor(message = \"Forbidden\") {\n    super(message, 403, \"FORBIDDEN\");\n  }\n}\n\n/**\n * Global error handler\n */\nexport const errorHandler: ErrorHandler = (err, c) => {\n  console.error(`[ERROR] ${err.message}`, {\n    name: err.name,\n    stack: process.env.NODE_ENV !== \"production\" ? err.stack : undefined,\n  });\n\n  // Handle HTTPException from Hono\n  if (err instanceof HTTPException) {\n    return c.json(\n      {\n        success: false,\n        message: err.message,\n        code: \"HTTP_EXCEPTION\",\n      },\n      err.status\n    );\n  }\n\n  // Handle custom AppError\n  if (err instanceof AppError) {\n    return c.json(\n      {\n        success: false,\n        message: err.message,\n        code: err.code,\n        ...(process.env.NODE_ENV !== \"production\" && { details: err.details }),\n      },\n      err.statusCode as any\n    );\n  }\n\n  // Handle unknown errors\n  return c.json(\n    {\n      success: false,\n      message:\n        process.env.NODE_ENV === \"production\"\n          ? \"Internal Server Error\"\n          : err.message,\n      ...(process.env.NODE_ENV !== \"production\" && { stack: err.stack }),\n    },\n    500\n  );\n};\n\n/**\n * Async handler wrapper to catch errors in route handlers\n */\nexport const asyncHandler = <T>(\n  fn: (c: any) => Promise<T>\n): ((c: any) => Promise<T>) => {\n  return async (c) => {\n    try {\n      return await fn(c);\n    } catch (error) {\n      throw error; // Let errorHandler catch it\n    }\n  };\n};\n",
  "hono-jwt": "import { jwt } from \"hono/jwt\";\nimport { createMiddleware } from \"hono/factory\";\nimport type { Context, Next } from \"hono\";\n\nconst JWT_SECRET = process.env.JWT_SECRET || \"it-is-so-secret\";\n\n/**\n * Standard JWT Middleware\n */\nexport const jwtMiddleware = jwt({\n  secret: JWT_SECRET,\n});\n\n/**\n * Role-Based Access Control (RBAC) Middleware\n */\nexport const checkRole = (roles: string[]) => {\n  return createMiddleware(async (c: Context, next: Next) => {\n    const payload = c.get(\"jwtPayload\");\n    \n    if (!payload || !payload.role || !roles.includes(payload.role)) {\n      return c.json({\n        success: false,\n        message: \"Forbidden: Insufficient permissions\",\n      }, 403);\n    }\n    \n    await next();\n  });\n};\n\n/**\n * Usage in app:\n * \n * app.use(\"/api/protected/*\", jwtMiddleware);\n * app.get(\"/api/admin\", checkRole([\"admin\"]), (c) => c.text(\"Admin only\"));\n */\n",
  "hono-logger": "import { logger } from \"hono/logger\";\nimport { createMiddleware } from \"hono/factory\";\n\n/**\n * Custom logger that includes request details and timing\n */\nexport const customLogger = createMiddleware(async (c, next) => {\n  const start = Date.now();\n  const method = c.req.method;\n  const path = c.req.path;\n  \n  await next();\n  \n  const ms = Date.now() - start;\n  const status = c.res.status;\n  \n  const logMessage = `[HONO] ${method} ${path} - ${status} (${ms}ms)`;\n  \n  if (status >= 500) {\n    console.error(`\\x1b[31m${logMessage}\\x1b[0m`);\n  } else if (status >= 400) {\n    console.warn(`\\x1b[33m${logMessage}\\x1b[0m`);\n  } else {\n    console.log(`\\x1b[32m${logMessage}\\x1b[0m`);\n  }\n});\n\n/**\n * Standard Hono logger integration\n */\nexport const setupLogger = (app: any) => {\n  app.use(\"*\", logger());\n  app.use(\"*\", customLogger);\n};\n",
  "hono-rate-limiter": "import { createMiddleware } from \"hono/factory\";\nimport type { Context, Next } from \"hono\";\n\ninterface RateLimitStore {\n  [key: string]: { count: number; resetTime: number };\n}\n\nconst store: RateLimitStore = {};\n\ninterface RateLimitOptions {\n  windowMs: number;\n  max: number;\n  message?: string;\n  keyGenerator?: (c: Context) => string;\n  skipSuccessfulRequests?: boolean;\n}\n\n/**\n * Creates a rate limiter middleware\n */\nexport const createRateLimiter = (options: RateLimitOptions) => {\n  const {\n    windowMs,\n    max,\n    message = \"Too many requests, please try again later.\",\n    keyGenerator = (c) =>\n      c.req.header(\"x-forwarded-for\")?.split(\",\")[0]?.trim() ||\n      c.req.header(\"x-real-ip\") ||\n      \"unknown\",\n    skipSuccessfulRequests = false,\n  } = options;\n\n  return createMiddleware(async (c: Context, next: Next) => {\n    const key = keyGenerator(c);\n    const now = Date.now();\n\n    // Initialize or reset if window expired\n    if (!store[key] || now > store[key].resetTime) {\n      store[key] = { count: 0, resetTime: now + windowMs };\n    }\n\n    // Check if limit exceeded\n    if (store[key].count >= max) {\n      c.header(\"X-RateLimit-Limit\", String(max));\n      c.header(\"X-RateLimit-Remaining\", \"0\");\n      c.header(\"X-RateLimit-Reset\", String(Math.ceil(store[key].resetTime / 1000)));\n      c.header(\"Retry-After\", String(Math.ceil((store[key].resetTime - now) / 1000)));\n\n      return c.json({ success: false, message }, 429);\n    }\n\n    // Increment counter before request\n    store[key].count++;\n\n    // Set rate limit headers\n    c.header(\"X-RateLimit-Limit\", String(max));\n    c.header(\"X-RateLimit-Remaining\", String(max - store[key].count));\n    c.header(\"X-RateLimit-Reset\", String(Math.ceil(store[key].resetTime / 1000)));\n\n    await next();\n\n    // Decrement counter for successful requests if configured\n    if (skipSuccessfulRequests && c.res.status < 400) {\n      store[key].count = Math.max(0, store[key].count - 1);\n    }\n  });\n};\n\n/**\n * Default rate limiter: 100 requests per 15 minutes\n */\nexport const defaultLimiter = createRateLimiter({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n});\n\n/**\n * Auth rate limiter: 5 attempts per 15 minutes (for login/signup)\n */\nexport const authLimiter = createRateLimiter({\n  windowMs: 15 * 60 * 1000,\n  max: 5,\n  message: \"Too many login attempts, please try again after 15 minutes.\",\n  skipSuccessfulRequests: true,\n});\n\n/**\n * API rate limiter: 1000 requests per hour (for API consumers)\n */\nexport const apiLimiter = createRateLimiter({\n  windowMs: 60 * 60 * 1000,\n  max: 1000,\n  message: \"API rate limit exceeded. Please try again later.\",\n  keyGenerator: (c) =>\n    c.req.header(\"x-api-key\") ||\n    c.req.header(\"x-forwarded-for\")?.split(\",\")[0]?.trim() ||\n    \"unknown\",\n});\n\n/**\n * Strict limiter: 10 requests per minute (for sensitive endpoints)\n */\nexport const strictLimiter = createRateLimiter({\n  windowMs: 60 * 1000,\n  max: 10,\n  message: \"Rate limit exceeded for this endpoint.\",\n});\n",
  "hono-security": "import { secureHeaders } from \"hono/secure-headers\";\nimport { Hono } from \"hono\";\n\n/**\n * Production security headers configuration\n */\nexport const productionSecurity = secureHeaders({\n  contentSecurityPolicy: {\n    defaultSrc: [\"'self'\"],\n    scriptSrc: [\"'self'\", \"https://trusted.cdn.com\"],\n    styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n    imgSrc: [\"'self'\", \"data:\", \"https:\"],\n    connectSrc: [\"'self'\", \"https://api.trusted.com\"],\n    fontSrc: [\"'self'\"],\n    objectSrc: [\"'none'\"],\n    mediaSrc: [\"'self'\"],\n    frameSrc: [\"'none'\"],\n    baseUri: [\"'self'\"],\n    formAction: [\"'self'\"],\n    frameAncestors: [\"'none'\"],\n    upgradeInsecureRequests: [],\n  },\n  strictTransportSecurity: \"max-age=31536000; includeSubDomains; preload\",\n  xFrameOptions: \"DENY\",\n  xContentTypeOptions: \"nosniff\",\n  referrerPolicy: \"strict-origin-when-cross-origin\",\n  xXssProtection: \"1; mode=block\",\n});\n\n/**\n * Development security headers (relaxed)\n */\nexport const developmentSecurity = secureHeaders({\n  contentSecurityPolicy: false,\n});\n\n/**\n * Setup security headers based on environment\n */\nexport const setupSecurity = (app: Hono) => {\n  const isProd = process.env.NODE_ENV === \"production\";\n  app.use(\"*\", isProd ? productionSecurity : developmentSecurity);\n};\n",
  "hono-zod": "import { z } from \"zod\";\nimport { zValidator } from \"@hono/zod-validator\";\nimport type { Context } from \"hono\";\n\n/**\n * Generic error formatter for Zod validation failures\n */\nexport const formatZodError = (result: any, c: Context) => {\n  if (!result.success) {\n    return c.json(\n      {\n        success: false,\n        message: \"Validation failed\",\n        errors: result.error.flatten().fieldErrors,\n      },\n      400\n    );\n  }\n};\n\n/**\n * Example: JSON Body Validation\n */\nexport const createUserSchema = z.object({\n  name: z.string().min(2),\n  email: z.string().email(),\n  password: z.string().min(8),\n});\n\nexport const validateCreateUser = zValidator(\"json\", createUserSchema, formatZodError);\n\n/**\n * Example: Query Parameter Validation\n */\nexport const paginationSchema = z.object({\n  page: z.string().optional().transform(Number).default(\"1\"),\n  limit: z.string().optional().transform(Number).default(\"10\"),\n});\n\nexport const validatePagination = zValidator(\"query\", paginationSchema, formatZodError);\n\n/**\n * Example: URL Parameter Validation\n */\nexport const idParamSchema = z.object({\n  id: z.string().uuid(\"Invalid ID format\"),\n});\n\nexport const validateIdParam = zValidator(\"param\", idParamSchema, formatZodError);\n"
}
