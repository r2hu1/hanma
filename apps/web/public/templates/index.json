{
  "base": [
    {
      "name": "express",
      "category": "base",
      "description": "Express.js v5 API starter with TypeScript",
      "framework": "express",
      "version": "5",
      "dependencies": [
        "zod",
        "express",
        "cors",
        "helmet"
      ],
      "devDependencies": [
        "typescript",
        "@types/node",
        "tsx",
        "@types/express",
        "@types/cors"
      ],
      "scripts": {
        "dev": "tsx watch src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js"
      },
      "envVars": [
        "PORT=3000",
        "NODE_ENV=development"
      ],
      "files": [
        {
          "path": "src/libs/server.ts",
          "content": "import http from \"http\";\nimport express from \"express\";\nimport cors from \"cors\";\nimport helmet from \"helmet\";\n\nconst app = express();\nconst server = http.createServer(app);\n\n// Track active connections for graceful shutdown\nconst sockets = new Set<import(\"net\").Socket>();\n\nserver.on(\"connection\", (socket) => {\n  sockets.add(socket);\n  socket.on(\"close\", () => sockets.delete(socket));\n});\n\n// Middleware\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(cors());\napp.use(helmet());\n\n// Health check endpoint\napp.get(\"/health\", (_req, res) => {\n  res.status(200).json({ status: \"ok\", timestamp: new Date().toISOString() });\n});\n\n// TODO: Add your routes here\n// app.use(\"/api\", yourRouter);\n\n// 404 handler\napp.use((_req, res) => {\n  res.status(404).json({ success: false, message: \"Resource not found\" });\n});\n\n// Error handler\napp.use((err: Error, _req: express.Request, res: express.Response, _next: express.NextFunction) => {\n  console.error(\"[ERROR]\", err.stack || err.message);\n  res.status(500).json({\n    success: false,\n    message: process.env.NODE_ENV === \"development\" ? err.message : \"Internal Server Error\",\n  });\n});\n\nconst PORT = process.env.PORT || 3000;\n\nexport const startServer = async () => {\n  if (server.listening) {\n    console.log(\"Server already running\");\n    return;\n  }\n\n  try {\n    server.listen(PORT, () => {\n      console.log(`Server running on http://localhost:${PORT}`);\n      console.log(`Health check: http://localhost:${PORT}/health`);\n    });\n  } catch (err) {\n    console.error(\"Failed to start server:\", err);\n    process.exit(1);\n  }\n};\n\nexport const shutdown = async (signal: string) => {\n  console.log(`\\n${signal} received. Shutting down gracefully...`);\n\n  server.close(() => {\n    console.log(\"HTTP server closed\");\n    process.exit(0);\n  });\n\n  // Force shutdown after 10s\n  setTimeout(() => {\n    console.warn(\n      `Grace period expired. Forcing close of ${sockets.size} remaining connection(s).`\n    );\n    sockets.forEach((socket) => socket.destroy());\n    process.exit(1);\n  }, 10000).unref();\n};\n\n// Start the server\nstartServer();\n\n// Graceful shutdown handlers\nprocess.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => shutdown(\"SIGINT\"));\n\nprocess.on(\"unhandledRejection\", (reason, p) => {\n  console.error(\"Unhandled Rejection at:\", p, \"reason:\", reason);\n});\n\nprocess.on(\"uncaughtException\", (err) => {\n  console.error(\"Uncaught Exception:\", err);\n  process.exit(1);\n});"
        },
        {
          "path": "src/libs/cors.ts",
          "content": "import cors, { CorsOptions } from \"cors\";\n\n/**\n * Parses environment variables to get allowed origins, methods, and headers.\n */\nconst getEnvConfig = () => {\n  const allowedOrigins: string[] = (process.env.CORS_ORIGINS ?? \"\")\n    .split(\",\")\n    .map((o: string) => o.trim())\n    .filter((o: string) => o.length > 0);\n\n  const allowedMethods: string[] = (process.env.CORS_METHODS ?? \"\")\n    .split(\",\")\n    .map((m: string) => m.trim())\n    .filter((m: string) => m.length > 0);\n\n  const allowedHeaders: string[] = (process.env.CORS_HEADERS ?? \"\")\n    .split(\",\")\n    .map((h: string) => h.trim())\n    .filter((h: string) => h.length > 0);\n\n  return { allowedOrigins, allowedMethods, allowedHeaders };\n};\n\nexport const { allowedOrigins, allowedMethods, allowedHeaders } =\n  getEnvConfig();\n\n/**\n * Creates valid CorsOptions based on provided or environment configuration.\n */\nexport const createCorsOptions = (\n  overrides?: Partial<CorsOptions> & {\n    origins?: string[];\n    methods?: string[];\n    headers?: string[];\n  }\n): CorsOptions => {\n  const origins = overrides?.origins ?? allowedOrigins;\n  const methods = overrides?.methods ?? allowedMethods;\n  const headers = overrides?.headers ?? allowedHeaders;\n\n  return {\n    origin: (\n      origin: string | undefined,\n      callback: (error: Error | null, allow?: boolean) => void\n    ) => {\n      // Allow requests with no origin (mobile apps, curl, same-origin)\n      if (!origin) return callback(null, true);\n\n      if (origins.length === 0 || origins.includes(origin)) {\n        callback(null, true);\n      } else {\n        callback(new Error(\"Not allowed by CORS\"));\n      }\n    },\n    methods,\n    allowedHeaders: headers,\n    credentials: true,\n    ...overrides,\n  };\n};\n\n/**\n * Check if critical CORS configuration is missing.\n * Useful for validating environment setup on startup.\n */\nexport const validateCorsConfig = () => {\n  if (\n    !allowedOrigins.length ||\n    !allowedMethods.length ||\n    !allowedHeaders.length\n  ) {\n    console.warn(\n      \" CORS configuration might be incomplete. Check CORS_ORIGINS, CORS_METHODS, and CORS_HEADERS .env variables.\"\n    );\n    return false;\n  }\n  return true;\n};\n\n// Default export uses strict environment variables but doesn't hard exit only warns if missing,\n// unless strict validation is called.\nconst defaultOptions = createCorsOptions();\nexport const corsMiddleware = cors(defaultOptions);\n"
        },
        {
          "path": "tsconfig.json",
          "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"CommonJS\",\n    \"rootDir\": \"./src\",\n    \"outDir\": \"./dist\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    },\n    \"resolveJsonModule\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"types\": [\"node\"]\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
        },
        {
          "path": ".env.example",
          "content": "# Environment\nNODE_ENV=development\nPORT=3000\n\n# Add your environment variables below\n"
        },
        {
          "path": "package.json.hbs",
          "content": "{\n  \"name\": \"{{projectName}}\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"tsx watch src/index.ts\",\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\"\n  },\n  \"dependencies\": {\n    \"express\": \"^5.0.0\",\n    \"dotenv\": \"^16.3.1\",\n    \"zod\": \"^3.22.4\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.3.3\",\n    \"@types/express\": \"^5.0.0\",\n    \"@types/node\": \"^20.10.0\",\n    \"tsx\": \"^4.7.0\"\n  }\n}\n"
        },
        {
          "path": "src/index.ts.hbs",
          "content": "import { shutdown, startServer } from \"@/libs/server\";\n\nstartServer();\n\nprocess.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => shutdown(\"SIGINT\"));\n\nprocess.on(\"unhandledRejection\", (reason, p) => {\n  console.error(\"Unhandled Rejection at:\", p, \"reason:\", reason);\n});\n\nprocess.on(\"uncaughtException\", (err) => {\n  console.error(\"Uncaught Exception:\", err);\n  process.exit(1);\n});"
        }
      ]
    },
    {
      "name": "express-graphql",
      "category": "base",
      "description": "Apollo GraphQL server with Express integration",
      "framework": "express",
      "version": "5",
      "dependencies": [
        "express",
        "@apollo/server",
        "graphql",
        "cors",
        "dotenv"
      ],
      "devDependencies": [
        "typescript",
        "@types/node",
        "@types/express",
        "@types/cors",
        "tsx"
      ],
      "scripts": {
        "dev": "tsx watch src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js"
      },
      "envVars": [
        "PORT=4000",
        "NODE_ENV=development"
      ],
      "files": [
        {
          "path": "src/libs/graphql-server.ts",
          "content": "import { ApolloServer } from '@apollo/server';\nimport { expressMiddleware } from '@apollo/server/express4';\nimport { ApolloServerPluginDrainHttpServer } from '@apollo/server/plugin/drainHttpServer';\nimport express from 'express';\nimport http from 'http';\nimport cors from 'cors';\n\n/**\n * GraphQL type definitions\n * Replace with your actual schema\n */\nconst typeDefs = `#graphql\n  type Query {\n    hello: String\n    health: HealthStatus\n  }\n\n  type HealthStatus {\n    status: String!\n    timestamp: String!\n  }\n`;\n\n/**\n * GraphQL resolvers\n * Replace with your actual resolvers\n */\nconst resolvers = {\n  Query: {\n    hello: () => 'Hello from GraphQL!',\n    health: () => ({\n      status: 'ok',\n      timestamp: new Date().toISOString(),\n    }),\n  },\n};\n\n/**\n * Context interface for type-safe resolvers\n */\nexport interface GraphQLContext {\n  // Add your context properties here\n  // user?: { id: string; email: string };\n}\n\n/**\n * Create and configure Apollo Server with Express\n */\nexport const createGraphQLServer = async (port = 4000) => {\n  const app = express();\n  const httpServer = http.createServer(app);\n\n  const server = new ApolloServer<GraphQLContext>({\n    typeDefs,\n    resolvers,\n    plugins: [\n      // Graceful shutdown plugin\n      ApolloServerPluginDrainHttpServer({ httpServer }),\n    ],\n    // Disable introspection in production\n    introspection: process.env.NODE_ENV !== 'production',\n  });\n\n  await server.start();\n\n  app.use(\n    '/graphql',\n    cors<cors.CorsRequest>(),\n    express.json(),\n    expressMiddleware(server, {\n      context: async ({ req }) => {\n        // Build your context here\n        // const token = req.headers.authorization || '';\n        // const user = await getUser(token);\n        return {\n          // user,\n        };\n      },\n    })\n  );\n\n  // Health check endpoint\n  app.get('/health', (_req, res) => {\n    res.json({ status: 'ok', timestamp: new Date().toISOString() });\n  });\n\n  await new Promise<void>((resolve) =>\n    httpServer.listen({ port }, resolve)\n  );\n\n  console.log(`GraphQL server running at http://localhost:${port}/graphql`);\n\n  return { app, httpServer, server };\n};\n\n/**\n * Start the server\n */\nif (require.main === module) {\n  createGraphQLServer().catch(console.error);\n}\n"
        },
        {
          "path": "tsconfig.json",
          "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"CommonJS\",\n    \"rootDir\": \"./src\",\n    \"outDir\": \"./dist\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    },\n    \"resolveJsonModule\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"types\": [\"node\"]\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
        },
        {
          "path": "src/index.ts.hbs",
          "content": "import { startGraphQLServer, shutdownGraphQLServer } from \"@/libs/graphql-server\";\n\nstartGraphQLServer();\n\nprocess.on(\"SIGTERM\", () => shutdownGraphQLServer(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => shutdownGraphQLServer(\"SIGINT\"));\n\nprocess.on(\"unhandledRejection\", (reason, p) => {\n  console.error(\"Unhandled Rejection at:\", p, \"reason:\", reason);\n});\n\nprocess.on(\"uncaughtException\", (err) => {\n  console.error(\"Uncaught Exception:\", err);\n  process.exit(1);\n});\n"
        }
      ]
    },
    {
      "name": "express-minimal",
      "category": "base",
      "description": "Minimal Express.js v5 setup with TypeScript",
      "framework": "express",
      "version": "5",
      "dependencies": [
        "express",
        "dotenv",
        "cors",
        "helmet"
      ],
      "devDependencies": [
        "typescript",
        "@types/node",
        "@types/express",
        "tsx",
        "@types/cors"
      ],
      "scripts": {
        "dev": "tsx watch src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js"
      },
      "envVars": [
        "PORT=3000",
        "NODE_ENV=development"
      ],
      "files": [
        {
          "path": "src/index.ts",
          "content": "import http from \"http\";\nimport express from \"express\";\nimport cors from \"cors\";\nimport helmet from \"helmet\";\n\nconst app = express();\nconst server = http.createServer(app);\n\n// Track active connections for graceful shutdown\nconst sockets = new Set<import(\"net\").Socket>();\n\nserver.on(\"connection\", (socket) => {\n  sockets.add(socket);\n  socket.on(\"close\", () => sockets.delete(socket));\n});\n\n// Middleware\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(cors());\napp.use(helmet());\n\n// Health check endpoint\napp.get(\"/health\", (_req, res) => {\n  res.status(200).json({ status: \"ok\", timestamp: new Date().toISOString() });\n});\n\n// TODO: Add your routes here\n// app.use(\"/api\", yourRouter);\n\n// 404 handler\napp.use((_req, res) => {\n  res.status(404).json({ success: false, message: \"Resource not found\" });\n});\n\n// Error handler\napp.use((err: Error, _req: express.Request, res: express.Response, _next: express.NextFunction) => {\n  console.error(\"[ERROR]\", err.stack || err.message);\n  res.status(500).json({\n    success: false,\n    message: process.env.NODE_ENV === \"development\" ? err.message : \"Internal Server Error\",\n  });\n});\n\nconst PORT = process.env.PORT || 3000;\n\nexport const startServer = async () => {\n  if (server.listening) {\n    console.log(\"Server already running\");\n    return;\n  }\n\n  try {\n    server.listen(PORT, () => {\n      console.log(`Server running on http://localhost:${PORT}`);\n      console.log(`Health check: http://localhost:${PORT}/health`);\n    });\n  } catch (err) {\n    console.error(\"Failed to start server:\", err);\n    process.exit(1);\n  }\n};\n\nexport const shutdown = async (signal: string) => {\n  console.log(`\\n${signal} received. Shutting down gracefully...`);\n\n  server.close(() => {\n    console.log(\"HTTP server closed\");\n    process.exit(0);\n  });\n\n  // Force shutdown after 10s\n  setTimeout(() => {\n    console.warn(\n      `Grace period expired. Forcing close of ${sockets.size} remaining connection(s).`\n    );\n    sockets.forEach((socket) => socket.destroy());\n    process.exit(1);\n  }, 10000).unref();\n};\n\n// Start the server\nstartServer();\n\n// Graceful shutdown handlers\nprocess.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => shutdown(\"SIGINT\"));\n\nprocess.on(\"unhandledRejection\", (reason, p) => {\n  console.error(\"Unhandled Rejection at:\", p, \"reason:\", reason);\n});\n\nprocess.on(\"uncaughtException\", (err) => {\n  console.error(\"Uncaught Exception:\", err);\n  process.exit(1);\n});"
        },
        {
          "path": "tsconfig.json",
          "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"CommonJS\",\n    \"rootDir\": \"./src\",\n    \"outDir\": \"./dist\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    },\n    \"resolveJsonModule\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"types\": [\"node\"]\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
        },
        {
          "path": "src/index.ts.hbs",
          "content": "import express from \"express\";\nimport dotenv from \"dotenv\";\n\ndotenv.config();\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(express.json());\n\n// Health check\napp.get(\"/health\", (_req, res) => {\n  res.json({ status: \"ok\", timestamp: new Date().toISOString() });\n});\n\n// Start server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on http://localhost:${PORT}`);\n});\n\n// Graceful shutdown\nconst shutdown = (signal: string) => {\n  console.log(`\\n${signal} received. Shutting down gracefully...`);\n  server.close(() => {\n    console.log(\"Server closed\");\n    process.exit(0);\n  });\n};\n\nprocess.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => shutdown(\"SIGINT\"));\n"
        }
      ]
    },
    {
      "name": "express-rest-api",
      "category": "base",
      "description": "Production-ready REST API with validation, error handling, and structured routing",
      "framework": "express",
      "version": "5",
      "dependencies": [
        "express",
        "cors",
        "helmet",
        "zod",
        "dotenv"
      ],
      "devDependencies": [
        "typescript",
        "@types/node",
        "@types/express",
        "@types/cors",
        "tsx"
      ],
      "scripts": {
        "dev": "tsx watch src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js"
      },
      "envVars": [
        "PORT=3000",
        "NODE_ENV=development",
        "CORS_ORIGIN=http://localhost:3000"
      ],
      "files": [
        {
          "path": "src/libs/server.ts",
          "content": "import http from \"http\";\nimport express from \"express\";\nimport cors from \"cors\";\nimport helmet from \"helmet\";\n\nconst app = express();\nconst server = http.createServer(app);\n\n// Track active connections for graceful shutdown\nconst sockets = new Set<import(\"net\").Socket>();\n\nserver.on(\"connection\", (socket) => {\n  sockets.add(socket);\n  socket.on(\"close\", () => sockets.delete(socket));\n});\n\n// Middleware\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(cors());\napp.use(helmet());\n\n// Health check endpoint\napp.get(\"/health\", (_req, res) => {\n  res.status(200).json({ status: \"ok\", timestamp: new Date().toISOString() });\n});\n\n// TODO: Add your routes here\n// app.use(\"/api\", yourRouter);\n\n// 404 handler\napp.use((_req, res) => {\n  res.status(404).json({ success: false, message: \"Resource not found\" });\n});\n\n// Error handler\napp.use((err: Error, _req: express.Request, res: express.Response, _next: express.NextFunction) => {\n  console.error(\"[ERROR]\", err.stack || err.message);\n  res.status(500).json({\n    success: false,\n    message: process.env.NODE_ENV === \"development\" ? err.message : \"Internal Server Error\",\n  });\n});\n\nconst PORT = process.env.PORT || 3000;\n\nexport const startServer = async () => {\n  if (server.listening) {\n    console.log(\"Server already running\");\n    return;\n  }\n\n  try {\n    server.listen(PORT, () => {\n      console.log(`Server running on http://localhost:${PORT}`);\n      console.log(`Health check: http://localhost:${PORT}/health`);\n    });\n  } catch (err) {\n    console.error(\"Failed to start server:\", err);\n    process.exit(1);\n  }\n};\n\nexport const shutdown = async (signal: string) => {\n  console.log(`\\n${signal} received. Shutting down gracefully...`);\n\n  server.close(() => {\n    console.log(\"HTTP server closed\");\n    process.exit(0);\n  });\n\n  // Force shutdown after 10s\n  setTimeout(() => {\n    console.warn(\n      `Grace period expired. Forcing close of ${sockets.size} remaining connection(s).`\n    );\n    sockets.forEach((socket) => socket.destroy());\n    process.exit(1);\n  }, 10000).unref();\n};\n\n// Start the server\nstartServer();\n\n// Graceful shutdown handlers\nprocess.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => shutdown(\"SIGINT\"));\n\nprocess.on(\"unhandledRejection\", (reason, p) => {\n  console.error(\"Unhandled Rejection at:\", p, \"reason:\", reason);\n});\n\nprocess.on(\"uncaughtException\", (err) => {\n  console.error(\"Uncaught Exception:\", err);\n  process.exit(1);\n});"
        },
        {
          "path": "src/libs/cors.ts",
          "content": "import cors, { CorsOptions } from \"cors\";\n\n/**\n * Parses environment variables to get allowed origins, methods, and headers.\n */\nconst getEnvConfig = () => {\n  const allowedOrigins: string[] = (process.env.CORS_ORIGINS ?? \"\")\n    .split(\",\")\n    .map((o: string) => o.trim())\n    .filter((o: string) => o.length > 0);\n\n  const allowedMethods: string[] = (process.env.CORS_METHODS ?? \"\")\n    .split(\",\")\n    .map((m: string) => m.trim())\n    .filter((m: string) => m.length > 0);\n\n  const allowedHeaders: string[] = (process.env.CORS_HEADERS ?? \"\")\n    .split(\",\")\n    .map((h: string) => h.trim())\n    .filter((h: string) => h.length > 0);\n\n  return { allowedOrigins, allowedMethods, allowedHeaders };\n};\n\nexport const { allowedOrigins, allowedMethods, allowedHeaders } =\n  getEnvConfig();\n\n/**\n * Creates valid CorsOptions based on provided or environment configuration.\n */\nexport const createCorsOptions = (\n  overrides?: Partial<CorsOptions> & {\n    origins?: string[];\n    methods?: string[];\n    headers?: string[];\n  }\n): CorsOptions => {\n  const origins = overrides?.origins ?? allowedOrigins;\n  const methods = overrides?.methods ?? allowedMethods;\n  const headers = overrides?.headers ?? allowedHeaders;\n\n  return {\n    origin: (\n      origin: string | undefined,\n      callback: (error: Error | null, allow?: boolean) => void\n    ) => {\n      // Allow requests with no origin (mobile apps, curl, same-origin)\n      if (!origin) return callback(null, true);\n\n      if (origins.length === 0 || origins.includes(origin)) {\n        callback(null, true);\n      } else {\n        callback(new Error(\"Not allowed by CORS\"));\n      }\n    },\n    methods,\n    allowedHeaders: headers,\n    credentials: true,\n    ...overrides,\n  };\n};\n\n/**\n * Check if critical CORS configuration is missing.\n * Useful for validating environment setup on startup.\n */\nexport const validateCorsConfig = () => {\n  if (\n    !allowedOrigins.length ||\n    !allowedMethods.length ||\n    !allowedHeaders.length\n  ) {\n    console.warn(\n      \" CORS configuration might be incomplete. Check CORS_ORIGINS, CORS_METHODS, and CORS_HEADERS .env variables.\"\n    );\n    return false;\n  }\n  return true;\n};\n\n// Default export uses strict environment variables but doesn't hard exit only warns if missing,\n// unless strict validation is called.\nconst defaultOptions = createCorsOptions();\nexport const corsMiddleware = cors(defaultOptions);\n"
        },
        {
          "path": "src/middleware/async-handler.ts",
          "content": "import { Request, Response, NextFunction, RequestHandler } from 'express';\n\n/**\n * Type for async request handlers\n */\ntype AsyncRequestHandler = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => Promise<unknown>;\n\n/**\n * Wraps an async route handler to automatically catch and forward errors\n * Eliminates the need for try-catch blocks in every route\n * \n * @example\n * // Instead of:\n * router.get('/users', async (req, res, next) => {\n *   try {\n *     const users = await User.findAll();\n *     res.json(users);\n *   } catch (err) {\n *     next(err);\n *   }\n * });\n * \n * // You can write:\n * router.get('/users', asyncHandler(async (req, res) => {\n *   const users = await User.findAll();\n *   res.json(users);\n * }));\n */\nexport const asyncHandler = (fn: AsyncRequestHandler): RequestHandler => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n};\n\n/**\n * Alternative syntax using higher-order function\n * Can be used as a decorator-like pattern\n * \n * @example\n * const getUsers = catchAsync(async (req, res) => {\n *   const users = await User.findAll();\n *   res.json(users);\n * });\n * \n * router.get('/users', getUsers);\n */\nexport const catchAsync = asyncHandler; // Alias for those who prefer this name\n\n/**\n * Wrap multiple handlers at once\n * \n * @example\n * const [getUser, createUser, deleteUser] = wrapHandlers(\n *   async (req, res) => { ... },\n *   async (req, res) => { ... },\n *   async (req, res) => { ... },\n * );\n */\nexport const wrapHandlers = (\n  ...handlers: AsyncRequestHandler[]\n): RequestHandler[] => {\n  return handlers.map(asyncHandler);\n};\n"
        },
        {
          "path": "tsconfig.json",
          "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"CommonJS\",\n    \"rootDir\": \"./src\",\n    \"outDir\": \"./dist\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    },\n    \"resolveJsonModule\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"types\": [\"node\"]\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
        },
        {
          "path": "src/index.ts.hbs",
          "content": "import { shutdown, startServer } from \"@/libs/server\";\n\nstartServer();\n\nprocess.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => shutdown(\"SIGINT\"));\n\nprocess.on(\"unhandledRejection\", (reason, p) => {\n  console.error(\"Unhandled Rejection at:\", p, \"reason:\", reason);\n});\n\nprocess.on(\"uncaughtException\", (err) => {\n  console.error(\"Uncaught Exception:\", err);\n  process.exit(1);\n});\n"
        }
      ]
    },
    {
      "name": "express-socket",
      "category": "base",
      "description": "Real-time server with Socket.io integration",
      "framework": "express",
      "version": "5",
      "dependencies": [
        "express",
        "socket.io",
        "cors",
        "dotenv",
        "jsonwebtoken"
      ],
      "devDependencies": [
        "typescript",
        "@types/node",
        "@types/express",
        "@types/cors",
        "tsx",
        "@types/jsonwebtoken"
      ],
      "scripts": {
        "dev": "tsx watch src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js"
      },
      "envVars": [
        "PORT=3000",
        "NODE_ENV=development",
        "CORS_ORIGIN=http://localhost:3000"
      ],
      "files": [
        {
          "path": "src/libs/socket-server.ts",
          "content": "import { Server, Socket } from \"socket.io\";\nimport jwt from \"jsonwebtoken\";\nimport type { Server as HTTPServer } from \"http\";\n\ninterface JwtPayloadOptions {\n  id: string;\n  email: string;\n  name: string;\n}\n\nexport interface AuthenticatedSocket extends Socket {\n  user?: JwtPayloadOptions;\n}\n\ninterface InitSocketOptions {\n  /** The HTTP server instance to attach socket.io to */\n  server: HTTPServer;\n  /**\n   * Allowed CORS origins\n   * @default \"*\"\n   */\n  allowedOrigins?: string | string[];\n  /**\n   * Allowed HTTP methods for CORS\n   * @default [\"GET\", \"POST\"]\n   */\n  allowedMethods?: string[];\n  /** Allowed headers for CORS */\n  allowedHeaders?: string[];\n  /**\n   * Whether to validate JWT token on connection handshake\n   * @default true\n   */\n  validateToken?: boolean;\n}\n\nexport function initializeSocket({\n  server,\n  allowedOrigins = \"*\",\n  allowedMethods = [\"GET\", \"POST\"],\n  allowedHeaders,\n  validateToken = true,\n}: InitSocketOptions): Server {\n  const io = new Server(server, {\n    cors: {\n      origin: allowedOrigins,\n      methods: allowedMethods,\n      allowedHeaders,\n      credentials: true,\n    },\n  });\n\n  io.use((socket: AuthenticatedSocket, next) => {\n    console.log(\n      `[${new Date().toISOString()}] Socket connected: ${socket.id}, ` +\n        `IP: ${socket.handshake.address}, ` +\n        `Transport: ${socket.conn.transport}`\n    );\n\n    // If validation is disabled, skip auth check\n    if (!validateToken) return next();\n\n    const token = socket.handshake.query.token as string;\n    if (!token) return next(new Error(\"Authentication error\"));\n\n    try {\n      const secret: jwt.Secret = process.env.JWT_ACCESS_SECRET!;\n      const decoded = jwt.verify(token, secret) as JwtPayloadOptions;\n      socket.user = decoded;\n      next();\n    } catch (err) {\n      console.error(\"JWT verification failed:\", err);\n      next(new Error(\"Authentication error\"));\n    }\n  });\n\n  return io;\n}\n"
        },
        {
          "path": "tsconfig.json",
          "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"CommonJS\",\n    \"rootDir\": \"./src\",\n    \"outDir\": \"./dist\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    },\n    \"resolveJsonModule\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"types\": [\"node\"]\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
        },
        {
          "path": "src/index.ts.hbs",
          "content": "import { startSocketServer, shutdownSocketServer } from \"@/libs/socket-server\";\n\nstartSocketServer();\n\nprocess.on(\"SIGTERM\", () => shutdownSocketServer(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => shutdownSocketServer(\"SIGINT\"));\n\nprocess.on(\"unhandledRejection\", (reason, p) => {\n  console.error(\"Unhandled Rejection at:\", p, \"reason:\", reason);\n});\n\nprocess.on(\"uncaughtException\", (err) => {\n  console.error(\"Uncaught Exception:\", err);\n  process.exit(1);\n});\n"
        }
      ]
    },
    {
      "name": "express-trpc",
      "category": "base",
      "description": "tRPC server with Express adapter for end-to-end type safety",
      "framework": "express",
      "version": "5",
      "dependencies": [
        "express",
        "@trpc/server",
        "zod",
        "cors",
        "dotenv"
      ],
      "devDependencies": [
        "typescript",
        "@types/node",
        "@types/express",
        "@types/cors",
        "tsx"
      ],
      "scripts": {
        "dev": "tsx watch src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js"
      },
      "envVars": [
        "PORT=3000",
        "NODE_ENV=development"
      ],
      "files": [
        {
          "path": "src/libs/trpc-server.ts",
          "content": "import { initTRPC, TRPCError } from '@trpc/server';\nimport { createExpressMiddleware } from '@trpc/server/adapters/express';\nimport express from 'express';\nimport { z } from 'zod';\n\n/**\n * Context creation function\n * Called for each request, provides context to all procedures\n */\nconst createContext = ({ req, res }: { req: express.Request; res: express.Response }) => {\n  // Extract user from auth header if present\n  // const token = req.headers.authorization?.split(' ')[1];\n  // const user = token ? verifyToken(token) : null;\n  \n  return {\n    req,\n    res,\n    // user,\n  };\n};\n\ntype Context = Awaited<ReturnType<typeof createContext>>;\n\n/**\n * Initialize tRPC with context\n */\nconst t = initTRPC.context<Context>().create({\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        // Add custom error data here\n      },\n    };\n  },\n});\n\n/**\n * Reusable middleware\n */\nconst isAuthenticated = t.middleware(({ ctx, next }) => {\n  // if (!ctx.user) {\n  //   throw new TRPCError({ code: 'UNAUTHORIZED' });\n  // }\n  return next({\n    ctx: {\n      ...ctx,\n      // user: ctx.user,\n    },\n  });\n});\n\n/**\n * Procedure builders\n */\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\nexport const protectedProcedure = t.procedure.use(isAuthenticated);\n\n/**\n * Example router with procedures\n */\nconst appRouter = router({\n  // Health check\n  health: publicProcedure.query(() => ({\n    status: 'ok',\n    timestamp: new Date().toISOString(),\n  })),\n\n  // Example public procedure\n  hello: publicProcedure\n    .input(z.object({ name: z.string().optional() }))\n    .query(({ input }) => {\n      return { greeting: `Hello ${input.name || 'World'}!` };\n    }),\n\n  // Example mutation\n  createItem: publicProcedure\n    .input(z.object({\n      title: z.string().min(1).max(100),\n      description: z.string().optional(),\n    }))\n    .mutation(async ({ input }) => {\n      // Save to database\n      const item = {\n        id: Math.random().toString(36).slice(2),\n        ...input,\n        createdAt: new Date(),\n      };\n      return item;\n    }),\n\n  // Nested routers\n  user: router({\n    list: publicProcedure.query(() => {\n      return [{ id: '1', name: 'John' }];\n    }),\n    byId: publicProcedure\n      .input(z.object({ id: z.string() }))\n      .query(({ input }) => {\n        return { id: input.id, name: 'John' };\n      }),\n  }),\n});\n\n/**\n * Export type for client usage\n */\nexport type AppRouter = typeof appRouter;\n\n/**\n * Create and start tRPC server with Express\n */\nexport const createTRPCServer = (port = 4000) => {\n  const app = express();\n\n  // Health check endpoint\n  app.get('/health', (_req, res) => {\n    res.json({ status: 'ok', timestamp: new Date().toISOString() });\n  });\n\n  // tRPC middleware\n  app.use(\n    '/trpc',\n    createExpressMiddleware({\n      router: appRouter,\n      createContext,\n      onError({ error, path }) {\n        console.error(`[ERROR] tRPC error on ${path}:`, error.message);\n      },\n    })\n  );\n\n  const server = app.listen(port, () => {\n    console.log(`tRPC server running at http://localhost:${port}/trpc`);\n  });\n\n  return { app, server, router: appRouter };\n};\n\n/**\n * Start the server\n */\nif (require.main === module) {\n  createTRPCServer();\n}\n"
        },
        {
          "path": "tsconfig.json",
          "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"CommonJS\",\n    \"rootDir\": \"./src\",\n    \"outDir\": \"./dist\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    },\n    \"resolveJsonModule\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"types\": [\"node\"]\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
        },
        {
          "path": "src/index.ts.hbs",
          "content": "import { startTRPCServer, shutdownTRPCServer } from \"@/libs/trpc-server\";\n\nstartTRPCServer();\n\nprocess.on(\"SIGTERM\", () => shutdownTRPCServer(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => shutdownTRPCServer(\"SIGINT\"));\n\nprocess.on(\"unhandledRejection\", (reason, p) => {\n  console.error(\"Unhandled Rejection at:\", p, \"reason:\", reason);\n});\n\nprocess.on(\"uncaughtException\", (err) => {\n  console.error(\"Uncaught Exception:\", err);\n  process.exit(1);\n});\n"
        }
      ]
    }
  ],
  "database": [
    {
      "name": "drizzle-mysql",
      "category": "database",
      "description": "Drizzle ORM with MySQL setup",
      "framework": "express",
      "dependencies": [
        "drizzle-orm",
        "mysql2",
        "dotenv"
      ],
      "devDependencies": [
        "drizzle-kit",
        "@types/node"
      ],
      "scripts": {
        "db:generate": "drizzle-kit generate",
        "db:push": "drizzle-kit push",
        "db:studio": "drizzle-kit studio"
      },
      "envVars": [
        "DATABASE_URL=mysql://user:password@localhost:3306/database"
      ],
      "files": [
        {
          "path": "drizzle.config.ts.hbs",
          "content": "import { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  schema: \"./src/db/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"mysql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n"
        },
        {
          "path": "src/db/index.ts.hbs",
          "content": "import { drizzle } from \"drizzle-orm/mysql2\";\nimport mysql from \"mysql2/promise\";\nimport * as schema from \"./schema/schema\";\n\n/**\n * MySQL connection pool\n */\nconst pool = mysql.createPool({\n  uri: process.env.DATABASE_URL,\n  waitForConnections: true,\n  connectionLimit: 20,        // Maximum connections in pool\n  queueLimit: 0,\n  enableKeepAlive: true,\n  keepAliveInitialDelay: 10000,\n});\n\n// Log pool errors\npool.on('error', (err) => {\n  console.error('[ERROR] Unexpected database pool error:', err);\n});\n\n/**\n * Drizzle ORM instance\n */\nexport const db = drizzle(pool, { schema, mode: 'default' });\n\n/**\n * Connect to database with health check\n */\nexport const connectDatabase = async () => {\n  try {\n    const connection = await pool.getConnection();\n    await connection.query('SELECT 1');\n    connection.release();\n    console.log('[OK] Database connected');\n  } catch (error) {\n    console.error('[ERROR] Database connection failed:', error);\n    throw error;\n  }\n};\n\n/**\n * Disconnect from database (for graceful shutdown)\n */\nexport const disconnectDatabase = async () => {\n  await pool.end();\n  console.log('[INFO] Database disconnected');\n};\n\n/**\n * Health check for database connection\n */\nexport const isDatabaseHealthy = async (): Promise<boolean> => {\n  try {\n    const connection = await pool.getConnection();\n    await connection.query('SELECT 1');\n    connection.release();\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Transaction helper\n * @example\n * await transaction(async (tx) => {\n *   await tx.insert(users).values({ name: 'John' });\n *   await tx.insert(posts).values({ title: 'Hello' });\n * });\n */\nexport const transaction = async <T>(\n  fn: (tx: typeof db) => Promise<T>\n): Promise<T> => {\n  return db.transaction(fn);\n};\n"
        },
        {
          "path": "src/db/schema/schema.ts.hbs",
          "content": "import { mysqlTable, serial, varchar, text, timestamp, boolean } from \"drizzle-orm/mysql-core\";\n\n// Example users table - modify as needed\nexport const users = mysqlTable(\"users\", {\n  id: serial(\"id\").primaryKey(),\n  email: varchar(\"email\", { length: 255 }).notNull().unique(),\n  name: text(\"name\"),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n  isDeleted: boolean(\"is_deleted\").default(false), // soft deletes\n});\n\nexport type User = typeof users.$inferSelect;\nexport type NewUser = typeof users.$inferInsert;\n"
        }
      ]
    },
    {
      "name": "drizzle-postgres",
      "category": "database",
      "description": "Drizzle ORM with PostgreSQL setup",
      "framework": "express",
      "dependencies": [
        "drizzle-orm",
        "pg",
        "dotenv"
      ],
      "devDependencies": [
        "drizzle-kit",
        "@types/pg"
      ],
      "scripts": {
        "db:generate": "drizzle-kit generate",
        "db:push": "drizzle-kit push",
        "db:studio": "drizzle-kit studio"
      },
      "envVars": [
        "DATABASE_URL"
      ],
      "files": [
        {
          "path": "drizzle.config.ts.hbs",
          "content": "import \"dotenv/config\";\nimport { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  schema: \"./src/db/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n"
        },
        {
          "path": "src/db/index.ts.hbs",
          "content": "import { drizzle } from 'drizzle-orm/node-postgres';\nimport * as schema from './schema/schema';\nimport { Pool } from 'pg';\n\n/**\n * PostgreSQL connection pool\n */\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  max: 20,                    // Maximum connections in pool\n  idleTimeoutMillis: 30000,   // Close idle connections after 30s\n  connectionTimeoutMillis: 5000,\n});\n\n// Log pool errors\npool.on('error', (err) => {\n  console.error('[ERROR] Unexpected database pool error:', err);\n});\n\n/**\n * Drizzle ORM instance\n * Import your schema and pass it here for type-safe queries\n */\nexport const db = drizzle(pool, { schema });\n\n/**\n * Connect to database with health check\n */\nexport const connectDatabase = async () => {\n  try {\n    const client = await pool.connect();\n    await client.query('SELECT NOW()');\n    client.release();\n    console.log('[OK] Database connected');\n  } catch (error) {\n    console.error('[ERROR] Database connection failed:', error);\n    throw error;\n  }\n};\n\n/**\n * Disconnect from database (for graceful shutdown)\n */\nexport const disconnectDatabase = async () => {\n  await pool.end();\n  console.log('[INFO] Database disconnected');\n};\n\n/**\n * Health check for database connection\n */\nexport const isDatabaseHealthy = async (): Promise<boolean> => {\n  try {\n    const client = await pool.connect();\n    await client.query('SELECT 1');\n    client.release();\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Transaction helper\n * @example\n * await transaction(async (tx) => {\n *   await tx.insert(users).values({ name: 'John' });\n *   await tx.insert(posts).values({ title: 'Hello' });\n * });\n */\nexport const transaction = async <T>(\n  fn: (tx: Parameters<typeof db.transaction>[0] extends (arg: infer A) => any\n    ? A\n    : never) => Promise<T>\n): Promise<T> => {\n  return db.transaction(fn);\n};\n"
        },
        {
          "path": "src/db/schema/schema.ts.hbs",
          "content": "import { pgTable, serial, text, timestamp, varchar, boolean } from \"drizzle-orm/pg-core\";\n\n// Example users table - modify as needed\nexport const users = pgTable(\"users\", {\n  id: serial(\"id\").primaryKey(),\n  email: varchar(\"email\", { length: 255 }).notNull().unique(),\n  name: text(\"name\"),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n  isDeleted: boolean(\"is_deleted\").default(false), // soft deletes\n});\n\nexport type User = typeof users.$inferSelect;\nexport type NewUser = typeof users.$inferInsert;\n"
        }
      ]
    },
    {
      "name": "drizzle-sqlite",
      "category": "database",
      "description": "Drizzle ORM with SQLite (better-sqlite3) setup",
      "framework": "express",
      "dependencies": [
        "drizzle-orm",
        "better-sqlite3",
        "dotenv"
      ],
      "devDependencies": [
        "drizzle-kit",
        "@types/better-sqlite3"
      ],
      "scripts": {
        "db:generate": "drizzle-kit generate",
        "db:push": "drizzle-kit push",
        "db:studio": "drizzle-kit studio"
      },
      "envVars": [
        "DATABASE_PATH=./data/database.db"
      ],
      "files": [
        {
          "path": "drizzle.config.ts.hbs",
          "content": "import { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  schema: \"./src/db/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"sqlite\",\n  dbCredentials: {\n    url: process.env.DATABASE_PATH || \"./data/database.db\",\n  },\n});\n"
        },
        {
          "path": "src/db/index.ts.hbs",
          "content": "import { drizzle } from \"drizzle-orm/better-sqlite3\";\nimport Database from \"better-sqlite3\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport * as schema from \"./schema/schema\";\n\nconst dbPath = process.env.DATABASE_PATH || \"./data/database.db\";\n\n// Ensure directory exists\nconst dir = path.dirname(dbPath);\nif (!fs.existsSync(dir)) {\n  fs.mkdirSync(dir, { recursive: true });\n}\n\n/**\n * SQLite database instance\n */\nconst sqlite = new Database(dbPath);\nsqlite.pragma(\"journal_mode = WAL\");\nsqlite.pragma(\"busy_timeout = 5000\");\nsqlite.pragma(\"synchronous = NORMAL\");\nsqlite.pragma(\"cache_size = -20000\"); // 20MB cache\nsqlite.pragma(\"foreign_keys = ON\");\n\n/**\n * Drizzle ORM instance\n */\nexport const db = drizzle(sqlite, { schema });\n\n/**\n * Connect to database with health check\n */\nexport const connectDatabase = () => {\n  try {\n    sqlite.exec(\"SELECT 1\");\n    console.log(\"[OK] Database connected\");\n  } catch (error) {\n    console.error(\"[ERROR] Database connection failed:\", error);\n    throw error;\n  }\n};\n\n/**\n * Disconnect from database (for graceful shutdown)\n */\nexport const disconnectDatabase = () => {\n  sqlite.close();\n  console.log(\"[INFO] Database disconnected\");\n};\n\n/**\n * Health check for database connection\n */\nexport const isDatabaseHealthy = (): boolean => {\n  try {\n    sqlite.exec(\"SELECT 1\");\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Transaction helper\n * @example\n * transaction((tx) => {\n *   tx.insert(users).values({ name: 'John' }).run();\n *   tx.insert(posts).values({ title: 'Hello' }).run();\n * });\n */\nexport const transaction = <T>(fn: (tx: typeof db) => T): T => {\n  return db.transaction(fn);\n};\n"
        },
        {
          "path": "src/db/schema/schema.ts.hbs",
          "content": "import { sqliteTable, integer, text } from \"drizzle-orm/sqlite-core\";\n\n// Example users table - modify as needed\nexport const users = sqliteTable(\"users\", {\n  id: integer(\"id\").primaryKey({ autoIncrement: true }),\n  email: text(\"email\").notNull().unique(),\n  name: text(\"name\"),\n  createdAt: integer(\"created_at\", { mode: \"timestamp\" }).notNull().$defaultFn(() => new Date()),\n  updatedAt: integer(\"updated_at\", { mode: \"timestamp\" }).notNull().$defaultFn(() => new Date()),\n  isDeleted: integer(\"is_deleted\", { mode: \"boolean\" }).default(false), // soft deletes\n});\n\nexport type User = typeof users.$inferSelect;\nexport type NewUser = typeof users.$inferInsert;\n"
        }
      ]
    },
    {
      "name": "mongodb",
      "category": "database",
      "description": "MongoDB native driver setup",
      "framework": "express",
      "dependencies": [
        "mongodb",
        "dotenv"
      ],
      "devDependencies": [],
      "envVars": [
        "MONGODB_URI=mongodb://localhost:27017/database"
      ],
      "files": [
        {
          "path": "src/db/index.ts.hbs",
          "content": "import { MongoClient, Db } from \"mongodb\";\n\nconst uri = process.env.MONGODB_URI || \"mongodb://localhost:27017/database\";\n\n/**\n * MongoDB client with connection pool options\n */\nconst client = new MongoClient(uri, {\n  maxPoolSize: 20,\n  minPoolSize: 5,\n  serverSelectionTimeoutMS: 5000,\n  socketTimeoutMS: 45000,\n});\n\nlet db: Db;\n\n/**\n * Connect to database with retry logic\n */\nexport async function connectDatabase(retries = 5, delay = 5000): Promise<Db> {\n  if (db) return db;\n\n  for (let i = 0; i < retries; i++) {\n    try {\n      await client.connect();\n      db = client.db();\n      console.log(\"[OK] MongoDB connected\");\n      return db;\n    } catch (error) {\n      console.error(`[ERROR] MongoDB connection failed (attempt ${i + 1}/${retries})`);\n      if (i < retries - 1) {\n        await new Promise((r) => setTimeout(r, delay));\n      }\n    }\n  }\n  throw new Error(\"Failed to connect to MongoDB after retries\");\n}\n\n/**\n * Disconnect from database (for graceful shutdown)\n */\nexport async function disconnectDatabase(): Promise<void> {\n  await client.close();\n  console.log(\"[INFO] MongoDB disconnected\");\n}\n\n/**\n * Get database instance\n */\nexport function getDB(): Db {\n  if (!db) {\n    throw new Error(\"Database not connected. Call connectDatabase() first.\");\n  }\n  return db;\n}\n\n/**\n * Health check for database connection\n */\nexport async function isDatabaseHealthy(): Promise<boolean> {\n  try {\n    await client.db().admin().ping();\n    return true;\n  } catch {\n    return false;\n  }\n}\n"
        }
      ]
    },
    {
      "name": "prisma-postgres",
      "category": "database",
      "description": "Prisma ORM with PostgreSQL setup",
      "framework": "express",
      "dependencies": [
        "@prisma/client",
        "dotenv"
      ],
      "devDependencies": [
        "prisma",
        "@types/node"
      ],
      "scripts": {
        "db:generate": "prisma generate",
        "db:push": "prisma db push",
        "db:studio": "prisma studio",
        "db:migrate": "prisma migrate dev"
      },
      "envVars": [
        "DATABASE_URL=postgresql://user:password@localhost:5432/database"
      ],
      "files": [
        {
          "path": "prisma/schema.prisma",
          "content": "generator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\n// Example model - uncomment and modify as needed\n// model User {\n//   id        String   @id @default(cuid())\n//   email     String   @unique\n//   name      String?\n//   createdAt DateTime @default(now())\n//   updatedAt DateTime @updatedAt\n// }\n"
        }
      ]
    }
  ],
  "auth": [
    {
      "name": "better-auth",
      "category": "auth",
      "description": "better-auth setup with session management",
      "framework": "express",
      "dependencies": [
        "better-auth"
      ],
      "devDependencies": [],
      "envVars": [
        "BETTER_AUTH_SECRET",
        "BETTER_AUTH_URL"
      ],
      "files": [
        {
          "path": "src/auth/index.ts.hbs",
          "content": "import { betterAuth } from \"better-auth\";\nimport { db } from \"../db\";\n\nexport const auth = betterAuth({\n  database: db,\n  emailAndPassword: {\n    enabled: true,\n  },\n  session: {\n    expiresIn: 60 * 60 * 24 * 7,\n    updateAge: 60 * 60 * 24,\n  },\n});\n\nexport type Session = typeof auth.$Infer.Session;\nexport type User = typeof auth.$Infer.User;\n"
        },
        {
          "path": "src/auth/routes.ts.hbs",
          "content": "import { Router } from \"express\";\nimport { toNodeHandler } from \"better-auth/node\";\nimport { auth } from \"./index\";\n\nconst router = Router();\nrouter.all(\"/api/auth/*\", toNodeHandler(auth));\n\nexport default router;\n"
        }
      ]
    },
    {
      "name": "jwt-auth",
      "category": "auth",
      "description": "Custom JWT authentication with refresh tokens",
      "framework": "express",
      "dependencies": [
        "jsonwebtoken"
      ],
      "devDependencies": [
        "@types/jsonwebtoken",
        "@types/express"
      ],
      "envVars": [
        "JWT_SECRET=your-secret-key-change-in-production",
        "JWT_EXPIRES_IN=15m",
        "JWT_REFRESH_EXPIRES_IN=7d"
      ],
      "files": [
        {
          "path": "src/middleware/auth.ts",
          "content": "import { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'changeme-in-production';\n\n/**\n * Extended Request interface with user payload\n */\nexport interface AuthenticatedRequest extends Request {\n  user?: JwtPayload;\n}\n\nexport interface JwtPayload {\n  id: string;\n  email: string;\n  role?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Extract JWT token from Authorization header\n * Supports: \"Bearer <token>\" format\n */\nconst extractToken = (req: Request): string | null => {\n  const authHeader = req.headers.authorization;\n  \n  if (!authHeader) return null;\n  \n  // Support \"Bearer <token>\" format\n  if (authHeader.startsWith('Bearer ')) {\n    return authHeader.slice(7);\n  }\n  \n  return authHeader;\n};\n\n/**\n * JWT Authentication Middleware\n * Verifies token and attaches decoded payload to req.user\n */\nexport const authenticate = (\n  req: AuthenticatedRequest,\n  res: Response,\n  next: NextFunction\n) => {\n  const token = extractToken(req);\n\n  if (!token) {\n    return res.status(401).json({\n      success: false,\n      message: 'Access denied. No token provided.',\n    });\n  }\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET) as JwtPayload;\n    req.user = decoded;\n    next();\n  } catch (error) {\n    if (error instanceof jwt.TokenExpiredError) {\n      return res.status(401).json({\n        success: false,\n        message: 'Token has expired.',\n      });\n    }\n    if (error instanceof jwt.JsonWebTokenError) {\n      return res.status(401).json({\n        success: false,\n        message: 'Invalid token.',\n      });\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Failed to authenticate token.',\n    });\n  }\n};\n\n/**\n * Optional authentication - doesn't fail if no token provided\n * Useful for routes that behave differently for logged-in users\n */\nexport const optionalAuth = (\n  req: AuthenticatedRequest,\n  res: Response,\n  next: NextFunction\n) => {\n  const token = extractToken(req);\n\n  if (!token) {\n    return next();\n  }\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET) as JwtPayload;\n    req.user = decoded;\n  } catch {\n    // Token invalid, but that's okay for optional auth\n  }\n  \n  next();\n};\n\n/**\n * Role-based authorization middleware\n * Use after authenticate middleware\n * @param allowedRoles - Array of roles that can access the route\n */\nexport const authorize = (...allowedRoles: string[]) => {\n  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        message: 'Authentication required.',\n      });\n    }\n\n    if (!req.user.role || !allowedRoles.includes(req.user.role)) {\n      return res.status(403).json({\n        success: false,\n        message: 'Insufficient permissions.',\n      });\n    }\n\n    next();\n  };\n};\n"
        }
      ]
    },
    {
      "name": "passport-local",
      "category": "auth",
      "description": "Passport.js with local username/password strategy",
      "framework": "express",
      "dependencies": [
        "passport",
        "passport-local",
        "express-session"
      ],
      "devDependencies": [
        "@types/passport",
        "@types/passport-local",
        "@types/express-session"
      ],
      "envVars": [
        "SESSION_SECRET=your-session-secret-change-in-production"
      ],
      "files": [
        {
          "path": "src/auth/passport.ts.hbs",
          "content": "import passport from \"passport\";\nimport { Strategy as LocalStrategy } from \"passport-local\";\n\n// Configure the local strategy\n// Replace with your actual user lookup logic\npassport.use(\n  new LocalStrategy(\n    {\n      usernameField: \"email\",\n      passwordField: \"password\",\n    },\n    async (email, password, done) => {\n      try {\n        // TODO: Replace with your user lookup\n        // const user = await findUserByEmail(email);\n        // if (!user) {\n        //   return done(null, false, { message: \"Incorrect email.\" });\n        // }\n        // const isValid = await verifyPassword(password, user.password);\n        // if (!isValid) {\n        //   return done(null, false, { message: \"Incorrect password.\" });\n        // }\n        // return done(null, user);\n        \n        return done(null, false, { message: \"Not implemented\" });\n      } catch (error) {\n        return done(error);\n      }\n    }\n  )\n);\n\n// Serialize user for session\npassport.serializeUser((user: any, done) => {\n  done(null, user.id);\n});\n\n// Deserialize user from session\npassport.deserializeUser(async (id: string, done) => {\n  try {\n    // TODO: Replace with your user lookup\n    // const user = await findUserById(id);\n    // done(null, user);\n    done(null, null);\n  } catch (error) {\n    done(error, null);\n  }\n});\n\nexport default passport;\n"
        }
      ]
    }
  ],
  "features": [
    {
      "name": "cache-redis",
      "category": "features",
      "description": "Redis caching layer with ioredis",
      "framework": "express",
      "dependencies": [
        "ioredis"
      ],
      "devDependencies": [],
      "envVars": [
        "REDIS_URL=redis://localhost:6379"
      ],
      "files": [],
      "featureType": "cache"
    },
    {
      "name": "logging-winston",
      "category": "features",
      "description": "Winston logging with Morgan HTTP request logging",
      "framework": "express",
      "dependencies": [
        "winston",
        "morgan"
      ],
      "devDependencies": [
        "@types/morgan",
        "@types/node"
      ],
      "envVars": [
        "LOG_LEVEL=info"
      ],
      "files": [
        {
          "path": "src/libs/logger.ts",
          "content": "\nimport winston from \"winston\";\nimport morgan from \"morgan\";\n\nconst levels = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  http: 3,\n  debug: 4,\n};\n\nconst level = () => {\n  const env = process.env.NODE_ENV || \"development\";\n  const isDevelopment = env === \"development\";\n  return isDevelopment ? \"debug\" : \"warn\";\n};\n\nconst colors = {\n  error: \"red\",\n  warn: \"yellow\",\n  info: \"green\",\n  http: \"magenta\",\n  debug: \"white\",\n};\n\nwinston.addColors(colors);\n\nconst format = winston.format.combine(\n  winston.format.timestamp({ format: \"YYYY-MM-DD HH:mm:ss:ms\" }),\n  winston.format.colorize({ all: true }),\n  winston.format.printf(\n    (info) => `${info.timestamp} ${info.level}: ${info.message}`\n  )\n);\n\nconst transports = [\n  new winston.transports.Console(),\n  // Add File transport if needed for production\n  // new winston.transports.File({\n  //   filename: 'logs/error.log',\n  //   level: 'error',\n  // }),\n  // new winston.transports.File({ filename: 'logs/all.log' }),\n];\n\nexport const logger = winston.createLogger({\n  level: level(),\n  levels,\n  format,\n  transports,\n});\n\nexport const apiLogger = morgan(\n  \":method :url :status :res[content-length] - :response-time ms\",\n  {\n    stream: {\n      write: (message) => logger.http(message.trim()),\n    },\n  }\n);\n\n"
        }
      ],
      "featureType": "logging"
    },
    {
      "name": "mailer-ses",
      "category": "features",
      "description": "Email sending with AWS SES",
      "framework": "express",
      "dependencies": [
        "@aws-sdk/client-ses"
      ],
      "devDependencies": [],
      "envVars": [
        "AWS_REGION=us-east-1",
        "AWS_ACCESS_KEY_ID=",
        "AWS_SECRET_ACCESS_KEY=",
        "MAIL_FROM=noreply@example.com"
      ],
      "files": [],
      "featureType": "mailer"
    },
    {
      "name": "mailer-nodemailer",
      "category": "features",
      "description": "Email sending with Nodemailer (SMTP)",
      "framework": "express",
      "dependencies": [
        "nodemailer"
      ],
      "devDependencies": [
        "@types/nodemailer"
      ],
      "envVars": [
        "SMTP_HOST=smtp.example.com",
        "SMTP_PORT=587",
        "SMTP_USER=",
        "SMTP_PASS=",
        "MAIL_FROM=noreply@example.com"
      ],
      "files": [],
      "featureType": "mailer"
    },
    {
      "name": "mailer-resend",
      "category": "features",
      "description": "Modern email API with Resend",
      "framework": "express",
      "dependencies": [
        "resend"
      ],
      "devDependencies": [],
      "envVars": [
        "RESEND_API_KEY=",
        "MAIL_FROM=noreply@example.com"
      ],
      "files": [],
      "featureType": "mailer"
    },
    {
      "name": "mailer-sendgrid",
      "category": "features",
      "description": "Email sending with SendGrid API",
      "framework": "express",
      "dependencies": [
        "@sendgrid/mail"
      ],
      "devDependencies": [],
      "envVars": [
        "SENDGRID_API_KEY=",
        "MAIL_FROM=noreply@example.com"
      ],
      "files": [],
      "featureType": "mailer"
    },
    {
      "name": "monitoring-sentry",
      "category": "features",
      "description": "Sentry error tracking and performance monitoring",
      "framework": "express",
      "dependencies": [
        "@sentry/node"
      ],
      "devDependencies": [
        "@types/express"
      ],
      "envVars": [
        "SENTRY_DSN=",
        "NODE_ENV=development"
      ],
      "files": [
        {
          "path": "src/libs/sentry.ts",
          "content": "import * as Sentry from '@sentry/node';\nimport { Express } from 'express';\n\n/**\n * Initialize Sentry\n * Call this at the very beginning of your program, before any other imports!\n */\nexport const initSentry = () => {\n  if (!process.env.SENTRY_DSN) {\n    console.warn('[WARN] SENTRY_DSN not set, error tracking disabled');\n    return;\n  }\n\n  Sentry.init({\n    dsn: process.env.SENTRY_DSN,\n    environment: process.env.NODE_ENV || 'development',\n    release: process.env.npm_package_version,\n    \n    // Performance Monitoring\n    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,\n    \n    // Only send errors in production\n    enabled: process.env.NODE_ENV === 'production',\n\n    // Add useful integrations for Express\n    integrations: [\n      // Sentry v8+ automatically adds many integrations\n    ],\n    \n    // Filter sensitive data\n    beforeSend(event) {\n      if (event.request?.headers) {\n        delete event.request.headers['authorization'];\n        delete event.request.headers['cookie'];\n        delete event.request.headers['x-api-key'];\n      }\n      return event;\n    },\n  });\n\n  console.log('[OK] Sentry initialized');\n};\n\n/**\n * Setup Sentry error handler\n * Add this AFTER your routes, but BEFORE any other error handlers\n */\nexport const setupSentryErrorHandler = (app: Express) => {\n  if (!process.env.SENTRY_DSN || process.env.NODE_ENV !== 'production') {\n    return;\n  }\n\n  Sentry.setupExpressErrorHandler(app);\n};\n\n/**\n * Capture exception manually\n */\nexport const captureException = (error: Error, context?: Record<string, unknown>) => {\n  Sentry.captureException(error, {\n    extra: context,\n  });\n};\n\n/**\n * Set user context for error tracking\n * Call this after user authentication\n */\nexport const setUser = (user: { id: string; email?: string; [key: string]: unknown }) => {\n  Sentry.setUser(user);\n};\n\n/**\n * Clear user context (on logout)\n */\nexport const clearUser = () => {\n  Sentry.setUser(null);\n};\n\n/**\n * Add breadcrumb for debugging\n */\nexport const addBreadcrumb = (message: string, category?: string, data?: Record<string, unknown>) => {\n  Sentry.addBreadcrumb({\n    message,\n    category: category || 'custom',\n    data,\n    level: 'info',\n  });\n};\n\n/**\n * Example usage in index.ts:\n * \n * 1. Initialize first:\n * import { initSentry } from './libs/sentry';\n * initSentry();\n * \n * 2. Setup app:\n * import express from 'express';\n * import { setupSentryErrorHandler } from './libs/sentry';\n * \n * const app = express();\n * \n * // Note: Request and Tracing handlers are now automatic in Sentry v8+ \n * // if initSentry is called before app initialization.\n * \n * // Your routes here\n * app.use('/api', routes);\n * \n * // 3. Error handler (must be after routes)\n * setupSentryErrorHandler(app);\n * \n * // Your custom error handler\n * app.use(errorHandler);\n */\n\n"
        }
      ],
      "featureType": "monitoring"
    },
    {
      "name": "tooling-biome",
      "category": "features",
      "description": "Biome for linting and formatting",
      "framework": "express",
      "dependencies": [],
      "devDependencies": [
        "@biomejs/biome"
      ],
      "scripts": {
        "lint": "biome check .",
        "format": "biome format . --write"
      },
      "envVars": [],
      "files": [
        {
          "path": "biome.json",
          "content": "{\n  \"$schema\": \"https://biomejs.dev/schemas/1.9.4/schema.json\",\n  \"organizeImports\": {\n    \"enabled\": true\n  },\n  \"linter\": {\n    \"enabled\": true,\n    \"rules\": {\n      \"recommended\": true\n    }\n  },\n  \"formatter\": {\n    \"enabled\": true,\n    \"indentStyle\": \"space\",\n    \"indentWidth\": 2,\n    \"lineWidth\": 80\n  }\n}\n"
        }
      ],
      "featureType": "tooling"
    },
    {
      "name": "tooling-eslint",
      "category": "features",
      "description": "ESLint for linting",
      "framework": "express",
      "dependencies": [],
      "devDependencies": [
        "eslint",
        "globals",
        "@eslint/js",
        "typescript-eslint"
      ],
      "scripts": {
        "lint": "eslint ."
      },
      "envVars": [],
      "files": [
        {
          "path": "eslint.config.mjs",
          "content": "import js from \"@eslint/js\";\nimport globals from \"globals\";\nimport tseslint from \"typescript-eslint\";\n\nexport default tseslint.config(\n  { ignores: [\"dist\"] },\n  js.configs.recommended,\n  ...tseslint.configs.recommended,\n  {\n    languageOptions: {\n      ecmaVersion: 2022,\n      globals: globals.node,\n    },\n    rules: {\n      \"@typescript-eslint/no-unused-vars\": [\"error\", { argsIgnorePattern: \"^_\" }],\n      \"@typescript-eslint/no-explicit-any\": \"warn\",\n    },\n  },\n);\n"
        }
      ],
      "featureType": "tooling"
    },
    {
      "name": "tooling-prettier",
      "category": "features",
      "description": "Prettier for formatting",
      "framework": "express",
      "dependencies": [],
      "devDependencies": [
        "prettier"
      ],
      "scripts": {
        "format": "prettier --write ."
      },
      "envVars": [],
      "files": [
        {
          "path": ".prettierrc",
          "content": "{\n  \"semi\": true,\n  \"singleQuote\": false,\n  \"tabWidth\": 2,\n  \"trailingComma\": \"all\",\n  \"printWidth\": 80\n}\n"
        }
      ],
      "featureType": "tooling"
    },
    {
      "name": "upload-cloudinary",
      "category": "features",
      "description": "Cloudinary file uploads with transformations",
      "framework": "express",
      "dependencies": [
        "cloudinary"
      ],
      "devDependencies": [],
      "envVars": [
        "CLOUDINARY_CLOUD_NAME=",
        "CLOUDINARY_API_KEY=",
        "CLOUDINARY_API_SECRET="
      ],
      "files": [],
      "featureType": "upload"
    },
    {
      "name": "upload-gcp",
      "category": "features",
      "description": "Google Cloud Storage uploads with signed URLs",
      "framework": "express",
      "dependencies": [
        "@google-cloud/storage"
      ],
      "devDependencies": [],
      "envVars": [
        "GCP_PROJECT_ID=",
        "GCS_BUCKET_NAME=",
        "GOOGLE_APPLICATION_CREDENTIALS="
      ],
      "files": [],
      "featureType": "upload"
    },
    {
      "name": "upload-local",
      "category": "features",
      "description": "Local file uploads with Multer",
      "framework": "express",
      "dependencies": [
        "multer"
      ],
      "devDependencies": [
        "@types/multer"
      ],
      "envVars": [
        "UPLOAD_DIR=uploads"
      ],
      "files": [
        {
          "path": "src/libs/upload.ts",
          "content": "import multer from 'multer';\nimport path from 'path';\n\n// Configure storage\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) => {\n    cb(null, 'uploads/'); // Ensure this directory exists\n  },\n  filename: (req, file, cb) => {\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);\n    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\n  },\n});\n\n// File filter (optional)\nconst fileFilter = (req: any, file: Express.Multer.File, cb: multer.FileFilterCallback) => {\n  if (file.mimetype.startsWith('image/')) {\n    cb(null, true);\n  } else {\n    cb(new Error('Only image files are allowed!'));\n  }\n};\n\nexport const upload = multer({ \n  storage: storage,\n  fileFilter: fileFilter,\n  limits: {\n    fileSize: 5 * 1024 * 1024, // 5MB limit\n  }\n});\n"
        }
      ],
      "featureType": "upload"
    },
    {
      "name": "upload-r2",
      "category": "features",
      "description": "Cloudflare R2 uploads (S3-compatible)",
      "framework": "express",
      "dependencies": [
        "@aws-sdk/client-s3",
        "@aws-sdk/s3-request-presigner"
      ],
      "devDependencies": [],
      "envVars": [
        "R2_ACCOUNT_ID=",
        "R2_ACCESS_KEY_ID=",
        "R2_SECRET_ACCESS_KEY=",
        "R2_BUCKET_NAME="
      ],
      "files": [],
      "featureType": "upload"
    },
    {
      "name": "upload-s3",
      "category": "features",
      "description": "AWS S3 file uploads with presigned URLs",
      "framework": "express",
      "dependencies": [
        "@aws-sdk/client-s3",
        "@aws-sdk/s3-request-presigner"
      ],
      "devDependencies": [],
      "envVars": [
        "AWS_REGION=us-east-1",
        "AWS_ACCESS_KEY_ID=",
        "AWS_SECRET_ACCESS_KEY=",
        "S3_BUCKET_NAME="
      ],
      "files": [],
      "featureType": "upload"
    }
  ],
  "presets": [
    {
      "name": "security-basic",
      "category": "presets",
      "description": "Basic security middleware bundle (Helmet, CORS, Rate Limiting)",
      "framework": "express",
      "dependencies": [
        "helmet",
        "cors",
        "express-rate-limit"
      ],
      "devDependencies": [
        "@types/cors",
        "@types/express",
        "@types/node"
      ],
      "envVars": [
        "CORS_ORIGIN=http://localhost:3000",
        "RATE_LIMIT_WINDOW_MS=900000",
        "RATE_LIMIT_MAX=100"
      ],
      "files": [
        {
          "path": "src/middleware/security/helmet.ts",
          "content": "import helmet from 'helmet';\nimport { RequestHandler } from 'express';\n\n/**\n * Production-ready security headers configuration\n * Customize based on your application's needs\n */\nexport const securityHeaders: RequestHandler = helmet({\n  // Content Security Policy - adjust for your needs\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"], // Allow inline styles if needed\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\"],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"],\n      upgradeInsecureRequests: [],\n    },\n  },\n  \n  // Strict Transport Security - force HTTPS\n  hsts: {\n    maxAge: 31536000, // 1 year\n    includeSubDomains: true,\n    preload: true,\n  },\n  \n  // Prevent clickjacking\n  frameguard: {\n    action: 'deny',\n  },\n  \n  // Prevent MIME type sniffing\n  noSniff: true,\n  \n  // XSS Protection (legacy browsers)\n  xssFilter: true,\n  \n  // Hide X-Powered-By header\n  hidePoweredBy: true,\n  \n  // Referrer Policy\n  referrerPolicy: {\n    policy: 'strict-origin-when-cross-origin',\n  },\n  \n  // Permissions Policy (formerly Feature Policy)\n  permittedCrossDomainPolicies: {\n    permittedPolicies: 'none',\n  },\n});\n\n/**\n * Relaxed security headers for development\n * DO NOT use in production!\n */\nexport const devSecurityHeaders: RequestHandler = helmet({\n  contentSecurityPolicy: false, // Disable CSP for easier development\n  hsts: false, // Don't force HTTPS in development\n});\n\n/**\n * API-specific security headers (no CSP needed)\n */\nexport const apiSecurityHeaders: RequestHandler = helmet({\n  contentSecurityPolicy: false, // APIs don't serve HTML\n  frameguard: false, // Not applicable for APIs\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n  },\n});\n\n/**\n * Get appropriate security headers based on environment\n */\nexport const getSecurityHeaders = (): RequestHandler => {\n  const env = process.env.NODE_ENV || 'development';\n  return env === 'production' ? securityHeaders : devSecurityHeaders;\n};\n"
        },
        {
          "path": "src/middleware/security/rate-limiter.ts",
          "content": "import rateLimit, { RateLimitRequestHandler } from 'express-rate-limit';\nimport { Request, Response } from 'express';\n\n/**\n * Default rate limiter for general API endpoints\n * 100 requests per 15 minutes per IP\n */\nexport const defaultLimiter: RateLimitRequestHandler = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100,\n  message: {\n    success: false,\n    message: 'Too many requests, please try again later.',\n  },\n  standardHeaders: true, // Return rate limit info in `RateLimit-*` headers\n  legacyHeaders: false,  // Disable `X-RateLimit-*` headers\n  keyGenerator: (req: Request) => {\n    // Use X-Forwarded-For for proxied requests, fallback to IP\n    return (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() \n      || req.ip \n      || 'unknown';\n  },\n});\n\n/**\n * Strict rate limiter for authentication endpoints\n * 5 attempts per 15 minutes per IP\n */\nexport const authLimiter: RateLimitRequestHandler = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5,\n  message: {\n    success: false,\n    message: 'Too many login attempts, please try again after 15 minutes.',\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n  skipSuccessfulRequests: true, // Don't count successful logins\n  keyGenerator: (req: Request) => {\n    return (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() \n      || req.ip \n      || 'unknown';\n  },\n});\n\n/**\n * API rate limiter for external API consumers\n * 1000 requests per hour per API key or IP\n */\nexport const apiLimiter: RateLimitRequestHandler = rateLimit({\n  windowMs: 60 * 60 * 1000, // 1 hour\n  max: 1000,\n  message: {\n    success: false,\n    message: 'API rate limit exceeded. Please try again later.',\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n  keyGenerator: (req: Request) => {\n    // Use API key if available, otherwise fall back to IP\n    const apiKey = req.headers['x-api-key'];\n    if (typeof apiKey === 'string') return apiKey;\n    \n    return (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() \n      || req.ip \n      || 'unknown';\n  },\n});\n\n/**\n * Create a custom rate limiter with specific options\n */\nexport const createLimiter = (options: {\n  windowMs: number;\n  max: number;\n  message?: string;\n  keyGenerator?: (req: Request) => string;\n}): RateLimitRequestHandler => {\n  return rateLimit({\n    windowMs: options.windowMs,\n    max: options.max,\n    message: {\n      success: false,\n      message: options.message || 'Too many requests.',\n    },\n    standardHeaders: true,\n    legacyHeaders: false,\n    keyGenerator: options.keyGenerator || ((req: Request) => {\n      return (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() \n        || req.ip \n        || 'unknown';\n    }),\n  });\n};\n"
        },
        {
          "path": "src/libs/cors.ts",
          "content": "import cors, { CorsOptions } from \"cors\";\n\n/**\n * Parses environment variables to get allowed origins, methods, and headers.\n */\nconst getEnvConfig = () => {\n  const allowedOrigins: string[] = (process.env.CORS_ORIGINS ?? \"\")\n    .split(\",\")\n    .map((o: string) => o.trim())\n    .filter((o: string) => o.length > 0);\n\n  const allowedMethods: string[] = (process.env.CORS_METHODS ?? \"\")\n    .split(\",\")\n    .map((m: string) => m.trim())\n    .filter((m: string) => m.length > 0);\n\n  const allowedHeaders: string[] = (process.env.CORS_HEADERS ?? \"\")\n    .split(\",\")\n    .map((h: string) => h.trim())\n    .filter((h: string) => h.length > 0);\n\n  return { allowedOrigins, allowedMethods, allowedHeaders };\n};\n\nexport const { allowedOrigins, allowedMethods, allowedHeaders } =\n  getEnvConfig();\n\n/**\n * Creates valid CorsOptions based on provided or environment configuration.\n */\nexport const createCorsOptions = (\n  overrides?: Partial<CorsOptions> & {\n    origins?: string[];\n    methods?: string[];\n    headers?: string[];\n  }\n): CorsOptions => {\n  const origins = overrides?.origins ?? allowedOrigins;\n  const methods = overrides?.methods ?? allowedMethods;\n  const headers = overrides?.headers ?? allowedHeaders;\n\n  return {\n    origin: (\n      origin: string | undefined,\n      callback: (error: Error | null, allow?: boolean) => void\n    ) => {\n      // Allow requests with no origin (mobile apps, curl, same-origin)\n      if (!origin) return callback(null, true);\n\n      if (origins.length === 0 || origins.includes(origin)) {\n        callback(null, true);\n      } else {\n        callback(new Error(\"Not allowed by CORS\"));\n      }\n    },\n    methods,\n    allowedHeaders: headers,\n    credentials: true,\n    ...overrides,\n  };\n};\n\n/**\n * Check if critical CORS configuration is missing.\n * Useful for validating environment setup on startup.\n */\nexport const validateCorsConfig = () => {\n  if (\n    !allowedOrigins.length ||\n    !allowedMethods.length ||\n    !allowedHeaders.length\n  ) {\n    console.warn(\n      \" CORS configuration might be incomplete. Check CORS_ORIGINS, CORS_METHODS, and CORS_HEADERS .env variables.\"\n    );\n    return false;\n  }\n  return true;\n};\n\n// Default export uses strict environment variables but doesn't hard exit only warns if missing,\n// unless strict validation is called.\nconst defaultOptions = createCorsOptions();\nexport const corsMiddleware = cors(defaultOptions);\n"
        }
      ]
    },
    {
      "name": "security-strict",
      "category": "presets",
      "description": "Production security middleware bundle with sanitization and request IDs",
      "framework": "express",
      "dependencies": [
        "helmet",
        "cors",
        "express-rate-limit",
        "sanitize-html",
        "compression",
        "uuid"
      ],
      "devDependencies": [
        "@types/cors",
        "@types/sanitize-html",
        "@types/compression",
        "@types/uuid",
        "@types/express",
        "@types/node"
      ],
      "envVars": [
        "CORS_ORIGIN=http://localhost:3000",
        "RATE_LIMIT_WINDOW_MS=900000",
        "RATE_LIMIT_MAX=100"
      ],
      "files": [
        {
          "path": "src/middleware/security/helmet.ts",
          "content": "import helmet from 'helmet';\nimport { RequestHandler } from 'express';\n\n/**\n * Production-ready security headers configuration\n * Customize based on your application's needs\n */\nexport const securityHeaders: RequestHandler = helmet({\n  // Content Security Policy - adjust for your needs\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"], // Allow inline styles if needed\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\"],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"],\n      upgradeInsecureRequests: [],\n    },\n  },\n  \n  // Strict Transport Security - force HTTPS\n  hsts: {\n    maxAge: 31536000, // 1 year\n    includeSubDomains: true,\n    preload: true,\n  },\n  \n  // Prevent clickjacking\n  frameguard: {\n    action: 'deny',\n  },\n  \n  // Prevent MIME type sniffing\n  noSniff: true,\n  \n  // XSS Protection (legacy browsers)\n  xssFilter: true,\n  \n  // Hide X-Powered-By header\n  hidePoweredBy: true,\n  \n  // Referrer Policy\n  referrerPolicy: {\n    policy: 'strict-origin-when-cross-origin',\n  },\n  \n  // Permissions Policy (formerly Feature Policy)\n  permittedCrossDomainPolicies: {\n    permittedPolicies: 'none',\n  },\n});\n\n/**\n * Relaxed security headers for development\n * DO NOT use in production!\n */\nexport const devSecurityHeaders: RequestHandler = helmet({\n  contentSecurityPolicy: false, // Disable CSP for easier development\n  hsts: false, // Don't force HTTPS in development\n});\n\n/**\n * API-specific security headers (no CSP needed)\n */\nexport const apiSecurityHeaders: RequestHandler = helmet({\n  contentSecurityPolicy: false, // APIs don't serve HTML\n  frameguard: false, // Not applicable for APIs\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n  },\n});\n\n/**\n * Get appropriate security headers based on environment\n */\nexport const getSecurityHeaders = (): RequestHandler => {\n  const env = process.env.NODE_ENV || 'development';\n  return env === 'production' ? securityHeaders : devSecurityHeaders;\n};\n"
        },
        {
          "path": "src/middleware/security/rate-limiter.ts",
          "content": "import rateLimit, { RateLimitRequestHandler } from 'express-rate-limit';\nimport { Request, Response } from 'express';\n\n/**\n * Default rate limiter for general API endpoints\n * 100 requests per 15 minutes per IP\n */\nexport const defaultLimiter: RateLimitRequestHandler = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100,\n  message: {\n    success: false,\n    message: 'Too many requests, please try again later.',\n  },\n  standardHeaders: true, // Return rate limit info in `RateLimit-*` headers\n  legacyHeaders: false,  // Disable `X-RateLimit-*` headers\n  keyGenerator: (req: Request) => {\n    // Use X-Forwarded-For for proxied requests, fallback to IP\n    return (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() \n      || req.ip \n      || 'unknown';\n  },\n});\n\n/**\n * Strict rate limiter for authentication endpoints\n * 5 attempts per 15 minutes per IP\n */\nexport const authLimiter: RateLimitRequestHandler = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5,\n  message: {\n    success: false,\n    message: 'Too many login attempts, please try again after 15 minutes.',\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n  skipSuccessfulRequests: true, // Don't count successful logins\n  keyGenerator: (req: Request) => {\n    return (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() \n      || req.ip \n      || 'unknown';\n  },\n});\n\n/**\n * API rate limiter for external API consumers\n * 1000 requests per hour per API key or IP\n */\nexport const apiLimiter: RateLimitRequestHandler = rateLimit({\n  windowMs: 60 * 60 * 1000, // 1 hour\n  max: 1000,\n  message: {\n    success: false,\n    message: 'API rate limit exceeded. Please try again later.',\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n  keyGenerator: (req: Request) => {\n    // Use API key if available, otherwise fall back to IP\n    const apiKey = req.headers['x-api-key'];\n    if (typeof apiKey === 'string') return apiKey;\n    \n    return (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() \n      || req.ip \n      || 'unknown';\n  },\n});\n\n/**\n * Create a custom rate limiter with specific options\n */\nexport const createLimiter = (options: {\n  windowMs: number;\n  max: number;\n  message?: string;\n  keyGenerator?: (req: Request) => string;\n}): RateLimitRequestHandler => {\n  return rateLimit({\n    windowMs: options.windowMs,\n    max: options.max,\n    message: {\n      success: false,\n      message: options.message || 'Too many requests.',\n    },\n    standardHeaders: true,\n    legacyHeaders: false,\n    keyGenerator: options.keyGenerator || ((req: Request) => {\n      return (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() \n        || req.ip \n        || 'unknown';\n    }),\n  });\n};\n"
        },
        {
          "path": "src/middleware/security/sanitize.ts",
          "content": "import { Request, Response, NextFunction } from 'express';\nimport sanitizeHtml from 'sanitize-html';\n\n/**\n * Sanitization options\n * Strips all HTML by default - adjust based on your needs\n */\nconst strictOptions: sanitizeHtml.IOptions = {\n  allowedTags: [],\n  allowedAttributes: {},\n  disallowedTagsMode: 'discard',\n};\n\n/**\n * Allow basic formatting tags (for rich text fields)\n */\nconst richTextOptions: sanitizeHtml.IOptions = {\n  allowedTags: ['b', 'i', 'u', 'em', 'strong', 'a', 'p', 'br', 'ul', 'ol', 'li'],\n  allowedAttributes: {\n    a: ['href', 'title', 'target'],\n  },\n  allowedSchemes: ['http', 'https', 'mailto'],\n};\n\n/**\n * Recursively sanitize all string values in an object\n */\nconst sanitizeObject = (\n  obj: unknown,\n  options: sanitizeHtml.IOptions = strictOptions\n): unknown => {\n  if (typeof obj === 'string') {\n    return sanitizeHtml(obj, options).trim();\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map((item) => sanitizeObject(item, options));\n  }\n\n  if (obj !== null && typeof obj === 'object') {\n    const sanitized: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(obj)) {\n      sanitized[key] = sanitizeObject(value, options);\n    }\n    return sanitized;\n  }\n\n  return obj;\n};\n\n/**\n * Strict sanitization middleware\n * Removes ALL HTML tags from request body, query, and params\n */\nexport const sanitizeStrict = (\n  req: Request,\n  _res: Response,\n  next: NextFunction\n) => {\n  if (req.body) {\n    req.body = sanitizeObject(req.body, strictOptions);\n  }\n  if (req.query) {\n    req.query = sanitizeObject(req.query, strictOptions) as typeof req.query;\n  }\n  if (req.params) {\n    req.params = sanitizeObject(req.params, strictOptions) as typeof req.params;\n  }\n  next();\n};\n\n/**\n * Rich text sanitization middleware\n * Allows basic formatting tags but strips dangerous content\n */\nexport const sanitizeRichText = (\n  req: Request,\n  _res: Response,\n  next: NextFunction\n) => {\n  if (req.body) {\n    req.body = sanitizeObject(req.body, richTextOptions);\n  }\n  next();\n};\n\n/**\n * Sanitize specific fields only\n * @param fields - Array of field names to sanitize in request body\n * @param allowRichText - If true, allows basic formatting tags\n */\nexport const sanitizeFields = (fields: string[], allowRichText = false) => {\n  const options = allowRichText ? richTextOptions : strictOptions;\n\n  return (req: Request, _res: Response, next: NextFunction) => {\n    if (req.body && typeof req.body === 'object') {\n      for (const field of fields) {\n        if (field in req.body && typeof req.body[field] === 'string') {\n          req.body[field] = sanitizeHtml(req.body[field], options).trim();\n        }\n      }\n    }\n    next();\n  };\n};\n\n/**\n * Utility function for manual sanitization\n */\nexport const sanitize = (\n  input: string,\n  allowRichText = false\n): string => {\n  const options = allowRichText ? richTextOptions : strictOptions;\n  return sanitizeHtml(input, options).trim();\n};\n"
        },
        {
          "path": "src/libs/cors.ts",
          "content": "import cors, { CorsOptions } from \"cors\";\n\n/**\n * Parses environment variables to get allowed origins, methods, and headers.\n */\nconst getEnvConfig = () => {\n  const allowedOrigins: string[] = (process.env.CORS_ORIGINS ?? \"\")\n    .split(\",\")\n    .map((o: string) => o.trim())\n    .filter((o: string) => o.length > 0);\n\n  const allowedMethods: string[] = (process.env.CORS_METHODS ?? \"\")\n    .split(\",\")\n    .map((m: string) => m.trim())\n    .filter((m: string) => m.length > 0);\n\n  const allowedHeaders: string[] = (process.env.CORS_HEADERS ?? \"\")\n    .split(\",\")\n    .map((h: string) => h.trim())\n    .filter((h: string) => h.length > 0);\n\n  return { allowedOrigins, allowedMethods, allowedHeaders };\n};\n\nexport const { allowedOrigins, allowedMethods, allowedHeaders } =\n  getEnvConfig();\n\n/**\n * Creates valid CorsOptions based on provided or environment configuration.\n */\nexport const createCorsOptions = (\n  overrides?: Partial<CorsOptions> & {\n    origins?: string[];\n    methods?: string[];\n    headers?: string[];\n  }\n): CorsOptions => {\n  const origins = overrides?.origins ?? allowedOrigins;\n  const methods = overrides?.methods ?? allowedMethods;\n  const headers = overrides?.headers ?? allowedHeaders;\n\n  return {\n    origin: (\n      origin: string | undefined,\n      callback: (error: Error | null, allow?: boolean) => void\n    ) => {\n      // Allow requests with no origin (mobile apps, curl, same-origin)\n      if (!origin) return callback(null, true);\n\n      if (origins.length === 0 || origins.includes(origin)) {\n        callback(null, true);\n      } else {\n        callback(new Error(\"Not allowed by CORS\"));\n      }\n    },\n    methods,\n    allowedHeaders: headers,\n    credentials: true,\n    ...overrides,\n  };\n};\n\n/**\n * Check if critical CORS configuration is missing.\n * Useful for validating environment setup on startup.\n */\nexport const validateCorsConfig = () => {\n  if (\n    !allowedOrigins.length ||\n    !allowedMethods.length ||\n    !allowedHeaders.length\n  ) {\n    console.warn(\n      \" CORS configuration might be incomplete. Check CORS_ORIGINS, CORS_METHODS, and CORS_HEADERS .env variables.\"\n    );\n    return false;\n  }\n  return true;\n};\n\n// Default export uses strict environment variables but doesn't hard exit only warns if missing,\n// unless strict validation is called.\nconst defaultOptions = createCorsOptions();\nexport const corsMiddleware = cors(defaultOptions);\n"
        },
        {
          "path": "src/middleware/request-id.ts",
          "content": "import { Request, Response, NextFunction } from 'express';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Header names for request ID\n */\nconst REQUEST_ID_HEADER = 'X-Request-ID';\nconst CORRELATION_ID_HEADER = 'X-Correlation-ID';\n\n/**\n * Extended request with ID fields\n */\nexport interface RequestWithId extends Request {\n  id: string;\n  correlationId?: string;\n}\n\n/**\n * Request ID Middleware\n * \n * Generates a unique ID for each request and attaches it to:\n * - req.id (for use in application code)\n * - Response header X-Request-ID (for client correlation)\n * \n * If the client sends X-Request-ID, it will be preserved.\n * If X-Correlation-ID is sent, it's stored for distributed tracing.\n */\nexport const requestId = (\n  req: RequestWithId,\n  res: Response,\n  next: NextFunction\n) => {\n  // Use existing request ID from client or generate new one\n  const existingId = req.headers[REQUEST_ID_HEADER.toLowerCase()] as string;\n  const id = existingId || uuidv4();\n\n  // Store correlation ID if provided (for distributed tracing)\n  const correlationId = req.headers[CORRELATION_ID_HEADER.toLowerCase()] as string;\n\n  // Attach to request object\n  req.id = id;\n  if (correlationId) {\n    req.correlationId = correlationId;\n  }\n\n  // Set response header so client can correlate\n  res.setHeader(REQUEST_ID_HEADER, id);\n  if (correlationId) {\n    res.setHeader(CORRELATION_ID_HEADER, correlationId);\n  }\n\n  next();\n};\n\n/**\n * Get request ID from request object (type-safe)\n */\nexport const getRequestId = (req: Request): string => {\n  return (req as RequestWithId).id || 'unknown';\n};\n\n/**\n * Create a child logger context with request ID\n * Useful for structured logging\n * \n * @example\n * const context = createLogContext(req);\n * logger.info('User logged in', context);\n * // Output: { requestId: '...', correlationId: '...', message: 'User logged in' }\n */\nexport const createLogContext = (req: Request) => {\n  const typedReq = req as RequestWithId;\n  return {\n    requestId: typedReq.id,\n    correlationId: typedReq.correlationId,\n    method: req.method,\n    path: req.path,\n    ip: req.ip,\n  };\n};\n"
        },
        {
          "path": "src/middleware/compression.ts",
          "content": "import compression from 'compression';\nimport { Request, Response, RequestHandler } from 'express';\n\n/**\n * Default compression middleware\n * Compresses responses larger than 1KB using gzip\n */\nexport const compress: RequestHandler = compression({\n  // Only compress responses larger than 1KB\n  threshold: 1024,\n  \n  // Compression level (1-9, higher = more compression but slower)\n  level: 6,\n  \n  // Filter function to decide what to compress\n  filter: (req: Request, res: Response) => {\n    // Don't compress if client doesn't accept it\n    if (req.headers['x-no-compression']) {\n      return false;\n    }\n    \n    // Use compression's default filter (checks Accept-Encoding)\n    return compression.filter(req, res);\n  },\n});\n\n/**\n * Aggressive compression for bandwidth-critical applications\n * Higher compression level, lower threshold\n */\nexport const compressAggressive: RequestHandler = compression({\n  threshold: 512,\n  level: 9,\n  filter: (req: Request, res: Response) => {\n    if (req.headers['x-no-compression']) {\n      return false;\n    }\n    return compression.filter(req, res);\n  },\n});\n\n/**\n * Light compression for CPU-constrained servers\n * Lower compression level, higher threshold\n */\nexport const compressLight: RequestHandler = compression({\n  threshold: 2048,\n  level: 1,\n  filter: (req: Request, res: Response) => {\n    if (req.headers['x-no-compression']) {\n      return false;\n    }\n    return compression.filter(req, res);\n  },\n});\n\n/**\n * Skip compression for specific content types\n * Useful when serving already-compressed content (images, videos)\n */\nexport const compressSelectiveTypes: RequestHandler = compression({\n  threshold: 1024,\n  level: 6,\n  filter: (req: Request, res: Response) => {\n    const contentType = res.getHeader('Content-Type') as string;\n    \n    // Skip already-compressed formats\n    const skipTypes = [\n      'image/',\n      'video/',\n      'audio/',\n      'application/zip',\n      'application/gzip',\n      'application/x-rar',\n    ];\n    \n    if (contentType && skipTypes.some(type => contentType.includes(type))) {\n      return false;\n    }\n    \n    if (req.headers['x-no-compression']) {\n      return false;\n    }\n    \n    return compression.filter(req, res);\n  },\n});\n"
        }
      ]
    }
  ],
  "extra": []
}
