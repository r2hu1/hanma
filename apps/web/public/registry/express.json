[
  {
    "name": "openapi",
    "description": "Contract-first OpenAPI validation and documentation",
    "dependencies": [
      "express-openapi-validator",
      "swagger-ui-express",
      "js-yaml"
    ],
    "devDependencies": [
      "@types/swagger-ui-express",
      "@types/js-yaml",
      "@types/express"
    ],
    "files": [
      {
        "name": "libs/docs/openapi.ts",
        "path": "libs/docs/openapi.ts",
        "content": "import path from 'path';\nimport express, { Express } from 'express';\nimport * as OpenApiValidator from 'express-openapi-validator';\nimport swaggerUi from 'swagger-ui-express';\nimport yaml from 'js-yaml';\nimport fs from 'fs';\n\n/**\n * Setup OpenAPI validation and documentation\n * This follows a contract-first approach where you define your API in openapi.yaml\n * \n * @param app Express application\n */\nexport const setupOpenApi = (app: Express) => {\n  const specPath = path.join(process.cwd(), 'docs/openapi.yaml');\n  \n  if (!fs.existsSync(specPath)) {\n    console.warn(`[WARN] OpenAPI spec not found at ${specPath}. Documentation and validation disabled.`);\n    return;\n  }\n\n  const spec = yaml.load(fs.readFileSync(specPath, 'utf8')) as Record<string, any>;\n\n  // 1. Serve Swagger UI\n  app.use('/docs', swaggerUi.serve, swaggerUi.setup(spec));\n\n  // 2. Install OpenAPI Validator\n  app.use(\n    OpenApiValidator.middleware({\n      apiSpec: specPath,\n      validateRequests: true,\n      validateResponses: true,\n    })\n  );\n\n  // 3. Error handler for validation errors\n  app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {\n    if (err.status) {\n      res.status(err.status).json({\n        message: err.message,\n        errors: err.errors,\n      });\n    } else {\n      next(err);\n    }\n  });\n\n  console.log('[OK] OpenAPI documentation and validation enabled');\n};\n\n/**\n * Example usage in index.ts:\n * \n * import express from 'express';\n * import { setupOpenApi } from './libs/docs/openapi';\n * \n * const app = express();\n * app.use(express.json());\n * \n * // Setup OpenAPI (Contract-first)\n * setupOpenApi(app);\n * \n * // Your routes here\n * // They will be automatically validated against openapi.yaml\n * \n * app.listen(3000);\n */\n\n---\n# docs/openapi.yaml\nopenapi: 3.0.0\ninfo:\n  title: Express API\n  version: 1.0.0\n  description: API documentation and contract\npaths:\n  /health:\n    get:\n      summary: Health check\n      responses:\n        '200':\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  status:\n                    type: string\n                    example: ok\n"
      },
      {
        "name": "docs/openapi.yaml",
        "path": "docs/openapi.yaml",
        "content": "import path from 'path';\nimport express, { Express } from 'express';\nimport * as OpenApiValidator from 'express-openapi-validator';\nimport swaggerUi from 'swagger-ui-express';\nimport yaml from 'js-yaml';\nimport fs from 'fs';\n\n/**\n * Setup OpenAPI validation and documentation\n * This follows a contract-first approach where you define your API in openapi.yaml\n * \n * @param app Express application\n */\nexport const setupOpenApi = (app: Express) => {\n  const specPath = path.join(process.cwd(), 'docs/openapi.yaml');\n  \n  if (!fs.existsSync(specPath)) {\n    console.warn(`[WARN] OpenAPI spec not found at ${specPath}. Documentation and validation disabled.`);\n    return;\n  }\n\n  const spec = yaml.load(fs.readFileSync(specPath, 'utf8')) as Record<string, any>;\n\n  // 1. Serve Swagger UI\n  app.use('/docs', swaggerUi.serve, swaggerUi.setup(spec));\n\n  // 2. Install OpenAPI Validator\n  app.use(\n    OpenApiValidator.middleware({\n      apiSpec: specPath,\n      validateRequests: true,\n      validateResponses: true,\n    })\n  );\n\n  // 3. Error handler for validation errors\n  app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {\n    if (err.status) {\n      res.status(err.status).json({\n        message: err.message,\n        errors: err.errors,\n      });\n    } else {\n      next(err);\n    }\n  });\n\n  console.log('[OK] OpenAPI documentation and validation enabled');\n};\n\n/**\n * Example usage in index.ts:\n * \n * import express from 'express';\n * import { setupOpenApi } from './libs/docs/openapi';\n * \n * const app = express();\n * app.use(express.json());\n * \n * // Setup OpenAPI (Contract-first)\n * setupOpenApi(app);\n * \n * // Your routes here\n * // They will be automatically validated against openapi.yaml\n * \n * app.listen(3000);\n */\n\n---\n# docs/openapi.yaml\nopenapi: 3.0.0\ninfo:\n  title: Express API\n  version: 1.0.0\n  description: API documentation and contract\npaths:\n  /health:\n    get:\n      summary: Health check\n      responses:\n        '200':\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  status:\n                    type: string\n                    example: ok\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "docs",
    "type": "module"
  },
  {
    "name": "swagger",
    "description": "Setup Swagger UI and JSDoc for API documentation",
    "dependencies": [
      "swagger-jsdoc",
      "swagger-ui-express"
    ],
    "devDependencies": [
      "@types/swagger-jsdoc",
      "@types/swagger-ui-express",
      "@types/express"
    ],
    "files": [
      {
        "name": "libs/docs/swagger.ts",
        "path": "libs/docs/swagger.ts",
        "content": "import swaggerJsdoc from 'swagger-jsdoc';\nimport swaggerUi from 'swagger-ui-express';\nimport { Express } from 'express';\n\nconst options: swaggerJsdoc.Options = {\n  definition: {\n    openapi: '3.0.0',\n    info: {\n      title: 'Express API with Swagger',\n      version: '1.0.0',\n      description: 'A simple Express API documented with Swagger',\n      license: {\n        name: 'MIT',\n        url: 'https://spdx.org/licenses/MIT.html',\n      },\n      contact: {\n        name: 'Hanma',\n        url: 'https://hanma.dev',\n        email: 'support@hanma.dev',\n      },\n    },\n    servers: [\n      {\n        url: 'http://localhost:3000',\n        description: 'Development server',\n      },\n    ],\n    components: {\n      securitySchemes: {\n        bearerAuth: {\n          type: 'http',\n          scheme: 'bearer',\n          bearerFormat: 'JWT',\n        },\n      },\n    },\n    security: [\n      {\n        bearerAuth: [],\n      },\n    ],\n  },\n  apis: ['./src/routes/*.ts', './src/models/*.ts'], // Path to the API docs\n};\n\nconst specs = swaggerJsdoc(options);\n\n/**\n * Setup Swagger documentation\n * @param app Express application\n */\nexport const setupSwagger = (app: Express) => {\n  // Swagger Page\n  app.use(\n    '/docs',\n    swaggerUi.serve,\n    swaggerUi.setup(specs, {\n      explorer: true,\n      customCss: '.swagger-ui .topbar { display: none }',\n      customSiteTitle: \"API Documentation\",\n    })\n  );\n\n  // Docs in JSON format\n  app.get('/docs.json', (req, res) => {\n    res.setHeader('Content-Type', 'application/json');\n    res.send(specs);\n  });\n\n  console.log('[OK] Swagger documentation available at /docs');\n};\n\n/**\n * Example JSDoc for a route:\n * \n * /**\n *  * @openapi\n *  * /users:\n *  *   get:\n *  *     tags:\n *  *       - Users\n *  *     description: Responds if the app is up and running\n *  *     responses:\n *  *       200:\n *  *         description: App is up and running\n *  * /\n */\n\n/**\n * Example usage in index.ts:\n * \n * import express from 'express';\n * import { setupSwagger } from './libs/docs/swagger';\n * \n * const app = express();\n * \n * // Setup Swagger\n * setupSwagger(app);\n * \n * // Your routes here\n * app.listen(3000);\n */\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "docs",
    "type": "snippet"
  },
  {
    "name": "zod-swagger",
    "description": "Programmatic OpenAPI documentation with Zod integration",
    "dependencies": [
      "zod",
      "@asteasolutions/zod-to-openapi",
      "swagger-ui-express"
    ],
    "devDependencies": [
      "@types/swagger-ui-express",
      "@types/express"
    ],
    "files": [
      {
        "name": "libs/docs/zod-swagger.ts",
        "path": "libs/docs/zod-swagger.ts",
        "content": "import { OpenAPIRegistry, OpenApiGeneratorV3, extendZodWithOpenApi } from '@asteasolutions/zod-to-openapi';\nimport { z } from 'zod';\nimport { Express, Router, Request, Response, NextFunction } from 'express';\nimport swaggerUi from 'swagger-ui-express';\n\n// Extend Zod with OpenAPI capabilities\nextendZodWithOpenApi(z);\n\n/**\n * Documentation Registry\n * Collects all routes and schemas for OpenAPI generation\n */\nexport const registry = new OpenAPIRegistry();\n\n/**\n * Documented Router Helper\n * Wraps Express Router to automatically register routes in the OpenAPI spec\n */\nexport const createDocumentedRouter = () => {\n  const router = Router();\n\n  return {\n    router,\n    /**\n     * Register a documented GET route\n     */\n    get: (path: string, schema: any, ...handlers: any[]) => {\n      registry.registerPath({\n        method: 'get',\n        path,\n        ...schema,\n      });\n      router.get(path, ...handlers);\n    },\n    /**\n     * Register a documented POST route\n     */\n    post: (path: string, schema: any, ...handlers: any[]) => {\n      registry.registerPath({\n        method: 'post',\n        path,\n        ...schema,\n      });\n      router.post(path, ...handlers);\n    },\n    // Add other methods (put, patch, delete) as needed...\n  };\n};\n\n/**\n * Generate OpenAPI Specification\n */\nexport const generateOpenApiSpec = () => {\n  const generator = new OpenApiGeneratorV3(registry.definitions);\n\n  return generator.generateDocument({\n    openapi: '3.0.0',\n    info: {\n      title: 'Express API',\n      version: '1.0.0',\n      description: 'API documentation generated automatically from Zod schemas',\n    },\n    servers: [{ url: '/api' }],\n  });\n};\n\n/**\n * Setup Swagger UI\n */\nexport const setupSwagger = (app: Express) => {\n  const spec = generateOpenApiSpec();\n\n  app.use('/docs', swaggerUi.serve, swaggerUi.setup(spec, {\n    customSiteTitle: \"API Documentation\",\n    customCss: '.swagger-ui .topbar { display: none }',\n  }));\n\n  app.get('/docs.json', (req: Request, res: Response) => {\n    res.json(spec);\n  });\n\n  console.log('[OK] Swagger UI available at /docs');\n};\n\n/**\n * @example\n * // 1. Define schemas\n * const UserSchema = registry.register('User', z.object({\n *   id: z.string().openapi({ example: '123' }),\n *   name: z.string().openapi({ example: 'John Doe' }),\n * }));\n * \n * // 2. Create documented router\n * const { router, post } = createDocumentedRouter();\n * \n * post('/users', {\n *   summary: 'Create a user',\n *   request: {\n *     body: {\n *       content: {\n *         'application/json': {\n *           schema: UserSchema,\n *         },\n *       },\n *     },\n *   },\n *   responses: {\n *     201: {\n *       description: 'User created successfully',\n *       content: {\n *         'application/json': {\n *           schema: UserSchema,\n *         },\n *       },\n *     },\n *   },\n * }, (req, res) => {\n *   res.status(201).json(req.body);\n * });\n */\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "docs",
    "type": "snippet"
  },
  {
    "name": "cors",
    "description": "Basic CORS setup for Express",
    "dependencies": [
      "cors"
    ],
    "devDependencies": [
      "@types/cors",
      "@types/node"
    ],
    "files": [
      {
        "name": "cors.ts",
        "path": "cors.ts",
        "content": "import cors, { CorsOptions } from \"cors\";\n\n/**\n * Parses environment variables to get allowed origins, methods, and headers.\n */\nconst getEnvConfig = () => {\n  const allowedOrigins: string[] = (process.env.CORS_ORIGINS ?? \"\")\n    .split(\",\")\n    .map((o: string) => o.trim())\n    .filter((o: string) => o.length > 0);\n\n  const allowedMethods: string[] = (process.env.CORS_METHODS ?? \"\")\n    .split(\",\")\n    .map((m: string) => m.trim())\n    .filter((m: string) => m.length > 0);\n\n  const allowedHeaders: string[] = (process.env.CORS_HEADERS ?? \"\")\n    .split(\",\")\n    .map((h: string) => h.trim())\n    .filter((h: string) => h.length > 0);\n\n  return { allowedOrigins, allowedMethods, allowedHeaders };\n};\n\nexport const { allowedOrigins, allowedMethods, allowedHeaders } =\n  getEnvConfig();\n\n/**\n * Creates valid CorsOptions based on provided or environment configuration.\n */\nexport const createCorsOptions = (\n  overrides?: Partial<CorsOptions> & {\n    origins?: string[];\n    methods?: string[];\n    headers?: string[];\n  }\n): CorsOptions => {\n  const origins = overrides?.origins ?? allowedOrigins;\n  const methods = overrides?.methods ?? allowedMethods;\n  const headers = overrides?.headers ?? allowedHeaders;\n\n  return {\n    origin: (\n      origin: string | undefined,\n      callback: (error: Error | null, allow?: boolean) => void\n    ) => {\n      // Allow requests with no origin (mobile apps, curl, same-origin)\n      if (!origin) return callback(null, true);\n\n      if (origins.length === 0 || origins.includes(origin)) {\n        callback(null, true);\n      } else {\n        callback(new Error(\"Not allowed by CORS\"));\n      }\n    },\n    methods,\n    allowedHeaders: headers,\n    credentials: true,\n    ...overrides,\n  };\n};\n\n/**\n * Check if critical CORS configuration is missing.\n * Useful for validating environment setup on startup.\n */\nexport const validateCorsConfig = () => {\n  if (\n    !allowedOrigins.length ||\n    !allowedMethods.length ||\n    !allowedHeaders.length\n  ) {\n    console.warn(\n      \" CORS configuration might be incomplete. Check CORS_ORIGINS, CORS_METHODS, and CORS_HEADERS .env variables.\"\n    );\n    return false;\n  }\n  return true;\n};\n\n// Default export uses strict environment variables but doesn't hard exit only warns if missing,\n// unless strict validation is called.\nconst defaultOptions = createCorsOptions();\nexport const corsMiddleware = cors(defaultOptions);\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "libs",
    "type": "snippet"
  },
  {
    "name": "s3-upload",
    "description": "AWS S3 file upload client with presigned URLs",
    "dependencies": [
      "@aws-sdk/client-s3",
      "@aws-sdk/s3-request-presigner"
    ],
    "files": [
      {
        "name": "libs/s3.ts",
        "path": "libs/s3.ts",
        "content": "import {\n  S3Client,\n  PutObjectCommand,\n  GetObjectCommand,\n  DeleteObjectCommand,\n  HeadObjectCommand,\n} from '@aws-sdk/client-s3';\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner';\nimport { randomBytes } from 'crypto';\n\n/**\n * S3 client configuration\n */\nconst s3Client = new S3Client({\n  region: process.env.AWS_REGION || 'us-east-1',\n  credentials: process.env.AWS_ACCESS_KEY_ID\n    ? {\n        accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || '',\n      }\n    : undefined, // Use IAM role if no credentials\n});\n\nconst BUCKET = process.env.S3_BUCKET || '';\n\n/**\n * Generate unique file key\n */\nconst generateKey = (filename: string, folder = 'uploads'): string => {\n  const ext = filename.split('.').pop() || '';\n  const uniqueId = randomBytes(8).toString('hex');\n  const date = new Date().toISOString().split('T')[0];\n  return `${folder}/${date}/${uniqueId}.${ext}`;\n};\n\n/**\n * Upload a file to S3\n */\nexport const uploadFile = async (\n  buffer: Buffer,\n  filename: string,\n  contentType: string,\n  folder = 'uploads'\n): Promise<{ key: string; url: string }> => {\n  const key = generateKey(filename, folder);\n\n  await s3Client.send(\n    new PutObjectCommand({\n      Bucket: BUCKET,\n      Key: key,\n      Body: buffer,\n      ContentType: contentType,\n    })\n  );\n\n  const url = `https://${BUCKET}.s3.amazonaws.com/${key}`;\n  return { key, url };\n};\n\n/**\n * Generate presigned upload URL (for direct browser upload)\n * @param filename - Original filename\n * @param contentType - MIME type\n * @param expiresIn - URL expiration in seconds (default: 5 minutes)\n */\nexport const getUploadUrl = async (\n  filename: string,\n  contentType: string,\n  expiresIn = 300,\n  folder = 'uploads'\n): Promise<{ uploadUrl: string; key: string; publicUrl: string }> => {\n  const key = generateKey(filename, folder);\n\n  const command = new PutObjectCommand({\n    Bucket: BUCKET,\n    Key: key,\n    ContentType: contentType,\n  });\n\n  const uploadUrl = await getSignedUrl(s3Client, command, { expiresIn });\n  const publicUrl = `https://${BUCKET}.s3.amazonaws.com/${key}`;\n\n  return { uploadUrl, key, publicUrl };\n};\n\n/**\n * Generate presigned download URL (for private files)\n * @param key - S3 object key\n * @param expiresIn - URL expiration in seconds (default: 1 hour)\n */\nexport const getDownloadUrl = async (\n  key: string,\n  expiresIn = 3600\n): Promise<string> => {\n  const command = new GetObjectCommand({\n    Bucket: BUCKET,\n    Key: key,\n  });\n\n  return getSignedUrl(s3Client, command, { expiresIn });\n};\n\n/**\n * Delete a file from S3\n */\nexport const deleteFile = async (key: string): Promise<void> => {\n  await s3Client.send(\n    new DeleteObjectCommand({\n      Bucket: BUCKET,\n      Key: key,\n    })\n  );\n};\n\n/**\n * Check if a file exists\n */\nexport const fileExists = async (key: string): Promise<boolean> => {\n  try {\n    await s3Client.send(\n      new HeadObjectCommand({\n        Bucket: BUCKET,\n        Key: key,\n      })\n    );\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Get file metadata\n */\nexport const getFileMetadata = async (key: string) => {\n  const response = await s3Client.send(\n    new HeadObjectCommand({\n      Bucket: BUCKET,\n      Key: key,\n    })\n  );\n\n  return {\n    contentType: response.ContentType,\n    contentLength: response.ContentLength,\n    lastModified: response.LastModified,\n    etag: response.ETag,\n  };\n};\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "libs",
    "type": "snippet"
  },
  {
    "name": "sentry",
    "description": "Sentry error tracking and performance monitoring setup",
    "dependencies": [
      "@sentry/node"
    ],
    "devDependencies": [
      "@types/express"
    ],
    "files": [
      {
        "name": "libs/sentry.ts",
        "path": "libs/sentry.ts",
        "content": "import * as Sentry from '@sentry/node';\nimport { Express } from 'express';\n\n/**\n * Initialize Sentry\n * Call this at the very beginning of your program, before any other imports!\n */\nexport const initSentry = () => {\n  if (!process.env.SENTRY_DSN) {\n    console.warn('[WARN] SENTRY_DSN not set, error tracking disabled');\n    return;\n  }\n\n  Sentry.init({\n    dsn: process.env.SENTRY_DSN,\n    environment: process.env.NODE_ENV || 'development',\n    release: process.env.npm_package_version,\n    \n    // Performance Monitoring\n    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,\n    \n    // Only send errors in production\n    enabled: process.env.NODE_ENV === 'production',\n\n    // Add useful integrations for Express\n    integrations: [\n      // Sentry v8+ automatically adds many integrations\n    ],\n    \n    // Filter sensitive data\n    beforeSend(event) {\n      if (event.request?.headers) {\n        delete event.request.headers['authorization'];\n        delete event.request.headers['cookie'];\n        delete event.request.headers['x-api-key'];\n      }\n      return event;\n    },\n  });\n\n  console.log('[OK] Sentry initialized');\n};\n\n/**\n * Setup Sentry error handler\n * Add this AFTER your routes, but BEFORE any other error handlers\n */\nexport const setupSentryErrorHandler = (app: Express) => {\n  if (!process.env.SENTRY_DSN || process.env.NODE_ENV !== 'production') {\n    return;\n  }\n\n  Sentry.setupExpressErrorHandler(app);\n};\n\n/**\n * Capture exception manually\n */\nexport const captureException = (error: Error, context?: Record<string, unknown>) => {\n  Sentry.captureException(error, {\n    extra: context,\n  });\n};\n\n/**\n * Set user context for error tracking\n * Call this after user authentication\n */\nexport const setUser = (user: { id: string; email?: string; [key: string]: unknown }) => {\n  Sentry.setUser(user);\n};\n\n/**\n * Clear user context (on logout)\n */\nexport const clearUser = () => {\n  Sentry.setUser(null);\n};\n\n/**\n * Add breadcrumb for debugging\n */\nexport const addBreadcrumb = (message: string, category?: string, data?: Record<string, unknown>) => {\n  Sentry.addBreadcrumb({\n    message,\n    category: category || 'custom',\n    data,\n    level: 'info',\n  });\n};\n\n/**\n * Example usage in index.ts:\n * \n * 1. Initialize first:\n * import { initSentry } from './libs/sentry';\n * initSentry();\n * \n * 2. Setup app:\n * import express from 'express';\n * import { setupSentryErrorHandler } from './libs/sentry';\n * \n * const app = express();\n * \n * // Note: Request and Tracing handlers are now automatic in Sentry v8+ \n * // if initSentry is called before app initialization.\n * \n * // Your routes here\n * app.use('/api', routes);\n * \n * // 3. Error handler (must be after routes)\n * setupSentryErrorHandler(app);\n * \n * // Your custom error handler\n * app.use(errorHandler);\n */\n\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "libs",
    "type": "snippet"
  },
  {
    "name": "express-server",
    "description": "Production-ready HTTP server setup with graceful shutdown",
    "dependencies": [
      "express",
      "cors",
      "helmet"
    ],
    "devDependencies": [
      "@types/node",
      "@types/express",
      "@types/cors"
    ],
    "files": [
      {
        "name": "libs/server.ts",
        "path": "libs/server.ts",
        "content": "import http from \"http\";\nimport express from \"express\";\nimport cors from \"cors\";\nimport helmet from \"helmet\";\n\nconst app = express();\nconst server = http.createServer(app);\n\n// Track active connections for graceful shutdown\nconst sockets = new Set<import(\"net\").Socket>();\n\nserver.on(\"connection\", (socket) => {\n  sockets.add(socket);\n  socket.on(\"close\", () => sockets.delete(socket));\n});\n\n// Middleware\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(cors());\napp.use(helmet());\n\n// Health check endpoint\napp.get(\"/health\", (_req, res) => {\n  res.status(200).json({ status: \"ok\", timestamp: new Date().toISOString() });\n});\n\n// TODO: Add your routes here\n// app.use(\"/api\", yourRouter);\n\n// 404 handler\napp.use((_req, res) => {\n  res.status(404).json({ success: false, message: \"Resource not found\" });\n});\n\n// Error handler\napp.use((err: Error, _req: express.Request, res: express.Response, _next: express.NextFunction) => {\n  console.error(\"[ERROR]\", err.stack || err.message);\n  res.status(500).json({\n    success: false,\n    message: process.env.NODE_ENV === \"development\" ? err.message : \"Internal Server Error\",\n  });\n});\n\nconst PORT = process.env.PORT || 3000;\n\nexport const startServer = async () => {\n  if (server.listening) {\n    console.log(\"Server already running\");\n    return;\n  }\n\n  try {\n    server.listen(PORT, () => {\n      console.log(`Server running on http://localhost:${PORT}`);\n      console.log(`Health check: http://localhost:${PORT}/health`);\n    });\n  } catch (err) {\n    console.error(\"Failed to start server:\", err);\n    process.exit(1);\n  }\n};\n\nexport const shutdown = async (signal: string) => {\n  console.log(`\\n${signal} received. Shutting down gracefully...`);\n\n  server.close(() => {\n    console.log(\"HTTP server closed\");\n    process.exit(0);\n  });\n\n  // Force shutdown after 10s\n  setTimeout(() => {\n    console.warn(\n      `Grace period expired. Forcing close of ${sockets.size} remaining connection(s).`\n    );\n    sockets.forEach((socket) => socket.destroy());\n    process.exit(1);\n  }, 10000).unref();\n};\n\n// Start the server\nstartServer();\n\n// Graceful shutdown handlers\nprocess.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => shutdown(\"SIGINT\"));\n\nprocess.on(\"unhandledRejection\", (reason, p) => {\n  console.error(\"Unhandled Rejection at:\", p, \"reason:\", reason);\n});\n\nprocess.on(\"uncaughtException\", (err) => {\n  console.error(\"Uncaught Exception:\", err);\n  process.exit(1);\n});"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "libs/servers",
    "type": "snippet"
  },
  {
    "name": "graphql-server",
    "description": "Apollo GraphQL server setup with Express integration",
    "dependencies": [
      "@apollo/server",
      "graphql"
    ],
    "devDependencies": [
      "@types/node"
    ],
    "files": [
      {
        "name": "libs/servers/graphql-server.ts",
        "path": "libs/servers/graphql-server.ts",
        "content": "import { ApolloServer } from '@apollo/server';\nimport { expressMiddleware } from '@apollo/server/express4';\nimport { ApolloServerPluginDrainHttpServer } from '@apollo/server/plugin/drainHttpServer';\nimport express from 'express';\nimport http from 'http';\nimport cors from 'cors';\n\n/**\n * GraphQL type definitions\n * Replace with your actual schema\n */\nconst typeDefs = `#graphql\n  type Query {\n    hello: String\n    health: HealthStatus\n  }\n\n  type HealthStatus {\n    status: String!\n    timestamp: String!\n  }\n`;\n\n/**\n * GraphQL resolvers\n * Replace with your actual resolvers\n */\nconst resolvers = {\n  Query: {\n    hello: () => 'Hello from GraphQL!',\n    health: () => ({\n      status: 'ok',\n      timestamp: new Date().toISOString(),\n    }),\n  },\n};\n\n/**\n * Context interface for type-safe resolvers\n */\nexport interface GraphQLContext {\n  // Add your context properties here\n  // user?: { id: string; email: string };\n}\n\n/**\n * Create and configure Apollo Server with Express\n */\nexport const createGraphQLServer = async (port = 4000) => {\n  const app = express();\n  const httpServer = http.createServer(app);\n\n  const server = new ApolloServer<GraphQLContext>({\n    typeDefs,\n    resolvers,\n    plugins: [\n      // Graceful shutdown plugin\n      ApolloServerPluginDrainHttpServer({ httpServer }),\n    ],\n    // Disable introspection in production\n    introspection: process.env.NODE_ENV !== 'production',\n  });\n\n  await server.start();\n\n  app.use(\n    '/graphql',\n    cors<cors.CorsRequest>(),\n    express.json(),\n    expressMiddleware(server, {\n      context: async ({ req }) => {\n        // Build your context here\n        // const token = req.headers.authorization || '';\n        // const user = await getUser(token);\n        return {\n          // user,\n        };\n      },\n    })\n  );\n\n  // Health check endpoint\n  app.get('/health', (_req, res) => {\n    res.json({ status: 'ok', timestamp: new Date().toISOString() });\n  });\n\n  await new Promise<void>((resolve) =>\n    httpServer.listen({ port }, resolve)\n  );\n\n  console.log(`GraphQL server running at http://localhost:${port}/graphql`);\n\n  return { app, httpServer, server };\n};\n\n/**\n * Start the server\n */\nif (require.main === module) {\n  createGraphQLServer().catch(console.error);\n}\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "libs/servers",
    "type": "snippet"
  },
  {
    "name": "grpc-server",
    "description": "gRPC server setup with health checking and graceful shutdown",
    "dependencies": [
      "@grpc/grpc-js",
      "@grpc/proto-loader"
    ],
    "devDependencies": [
      "@types/node"
    ],
    "files": [
      {
        "name": "libs/servers/grpc-server.ts",
        "path": "libs/servers/grpc-server.ts",
        "content": "import * as grpc from '@grpc/grpc-js';\nimport * as protoLoader from '@grpc/proto-loader';\nimport path from 'path';\n\n/**\n * Proto file loading options\n */\nconst PROTO_LOADER_OPTIONS: protoLoader.Options = {\n  keepCase: true,\n  longs: String,\n  enums: String,\n  defaults: true,\n  oneofs: true,\n};\n\n/**\n * Load proto definition\n * Create a .proto file and update the path\n */\nconst loadProtoDefinition = (protoPath: string) => {\n  const packageDefinition = protoLoader.loadSync(protoPath, PROTO_LOADER_OPTIONS);\n  return grpc.loadPackageDefinition(packageDefinition);\n};\n\n/**\n * Example service implementation\n * Replace with your actual service handlers\n */\nconst exampleServiceHandlers = {\n  // Unary RPC\n  SayHello: (\n    call: grpc.ServerUnaryCall<{ name: string }, { message: string }>,\n    callback: grpc.sendUnaryData<{ message: string }>\n  ) => {\n    const name = call.request.name || 'World';\n    callback(null, { message: `Hello ${name}!` });\n  },\n\n  // Server streaming RPC\n  StreamNumbers: (\n    call: grpc.ServerWritableStream<{ count: number }, { number: number }>\n  ) => {\n    const count = call.request.count || 5;\n    for (let i = 1; i <= count; i++) {\n      call.write({ number: i });\n    }\n    call.end();\n  },\n\n  // Client streaming RPC\n  AccumulateNumbers: (\n    call: grpc.ServerReadableStream<{ number: number }, { sum: number }>,\n    callback: grpc.sendUnaryData<{ sum: number }>\n  ) => {\n    let sum = 0;\n    call.on('data', (data: { number: number }) => {\n      sum += data.number;\n    });\n    call.on('end', () => {\n      callback(null, { sum });\n    });\n  },\n\n  // Bidirectional streaming RPC\n  Chat: (\n    call: grpc.ServerDuplexStream<{ message: string }, { reply: string }>\n  ) => {\n    call.on('data', (data: { message: string }) => {\n      call.write({ reply: `You said: ${data.message}` });\n    });\n    call.on('end', () => {\n      call.end();\n    });\n  },\n};\n\n/**\n * Health check service implementation\n * Standard gRPC health checking protocol\n */\nconst healthServiceHandlers = {\n  Check: (\n    call: grpc.ServerUnaryCall<{ service: string }, { status: number }>,\n    callback: grpc.sendUnaryData<{ status: number }>\n  ) => {\n    // 0 = UNKNOWN, 1 = SERVING, 2 = NOT_SERVING\n    callback(null, { status: 1 });\n  },\n  Watch: (\n    call: grpc.ServerWritableStream<{ service: string }, { status: number }>\n  ) => {\n    // Send current status\n    call.write({ status: 1 });\n    // Keep stream open for status updates\n  },\n};\n\n/**\n * Create and configure gRPC server\n */\nexport const createGRPCServer = async (port = 50051) => {\n  const server = new grpc.Server();\n\n  // Add your services here\n  // const proto = loadProtoDefinition(path.join(__dirname, 'your-service.proto'));\n  // server.addService(proto.yourpackage.YourService.service, exampleServiceHandlers);\n  \n  // Example: Add health service\n  // const healthProto = loadProtoDefinition(path.join(__dirname, 'health.proto'));\n  // server.addService(healthProto.grpc.health.v1.Health.service, healthServiceHandlers);\n\n  return new Promise<grpc.Server>((resolve, reject) => {\n    server.bindAsync(\n      `0.0.0.0:${port}`,\n      grpc.ServerCredentials.createInsecure(),\n      (error, boundPort) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        console.log(`gRPC server running on port ${boundPort}`);\n        resolve(server);\n      }\n    );\n  });\n};\n\n/**\n * Graceful shutdown handler\n */\nexport const shutdownGRPCServer = (server: grpc.Server): Promise<void> => {\n  return new Promise((resolve) => {\n    console.log('Shutting down gRPC server...');\n    server.tryShutdown((error) => {\n      if (error) {\n        console.error('[ERROR] gRPC shutdown error:', error);\n        server.forceShutdown();\n      }\n      console.log('gRPC server stopped');\n      resolve();\n    });\n  });\n};\n\n/**\n * Start the server\n */\nif (require.main === module) {\n  createGRPCServer()\n    .then((server) => {\n      process.on('SIGTERM', () => shutdownGRPCServer(server));\n      process.on('SIGINT', () => shutdownGRPCServer(server));\n    })\n    .catch(console.error);\n}\n\n/**\n * Example .proto file content:\n * \n * syntax = \"proto3\";\n * package example;\n * \n * service ExampleService {\n *   rpc SayHello (HelloRequest) returns (HelloResponse);\n *   rpc StreamNumbers (NumberRequest) returns (stream NumberResponse);\n *   rpc AccumulateNumbers (stream NumberRequest) returns (SumResponse);\n *   rpc Chat (stream ChatMessage) returns (stream ChatReply);\n * }\n * \n * message HelloRequest { string name = 1; }\n * message HelloResponse { string message = 1; }\n * message NumberRequest { int32 number = 1; }\n * message NumberResponse { int32 number = 1; }\n * message SumResponse { int32 sum = 1; }\n * message ChatMessage { string message = 1; }\n * message ChatReply { string reply = 1; }\n */\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "libs/servers",
    "type": "snippet"
  },
  {
    "name": "http-server",
    "description": "Standalone HTTP server without Express (native Node.js)",
    "dependencies": [],
    "devDependencies": [
      "@types/node"
    ],
    "files": [
      {
        "name": "libs/servers/http-server.ts",
        "path": "libs/servers/http-server.ts",
        "content": "import http from 'http';\nimport { URL } from 'url';\n\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';\n\ninterface RouteHandler {\n  (req: http.IncomingMessage, res: http.ServerResponse, params: Record<string, string>): void | Promise<void>;\n}\n\ninterface Route {\n  method: HttpMethod;\n  pattern: RegExp;\n  paramNames: string[];\n  handler: RouteHandler;\n}\n\n/**\n * Simple router for native HTTP server\n */\nclass Router {\n  private routes: Route[] = [];\n\n  private createRoute(method: HttpMethod, path: string, handler: RouteHandler) {\n    // Convert path params like :id to regex capture groups\n    const paramNames: string[] = [];\n    const pattern = path.replace(/:([^/]+)/g, (_, name) => {\n      paramNames.push(name);\n      return '([^/]+)';\n    });\n    \n    this.routes.push({\n      method,\n      pattern: new RegExp(`^${pattern}$`),\n      paramNames,\n      handler,\n    });\n  }\n\n  get(path: string, handler: RouteHandler) { this.createRoute('GET', path, handler); }\n  post(path: string, handler: RouteHandler) { this.createRoute('POST', path, handler); }\n  put(path: string, handler: RouteHandler) { this.createRoute('PUT', path, handler); }\n  patch(path: string, handler: RouteHandler) { this.createRoute('PATCH', path, handler); }\n  delete(path: string, handler: RouteHandler) { this.createRoute('DELETE', path, handler); }\n\n  match(method: string, path: string): { handler: RouteHandler; params: Record<string, string> } | null {\n    for (const route of this.routes) {\n      if (route.method !== method) continue;\n      \n      const match = path.match(route.pattern);\n      if (match) {\n        const params: Record<string, string> = {};\n        route.paramNames.forEach((name, i) => {\n          params[name] = match[i + 1];\n        });\n        return { handler: route.handler, params };\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Parse JSON body from request\n */\nconst parseBody = <T>(req: http.IncomingMessage): Promise<T> => {\n  return new Promise((resolve, reject) => {\n    let body = '';\n    req.on('data', (chunk) => { body += chunk; });\n    req.on('end', () => {\n      try {\n        resolve(body ? JSON.parse(body) : {} as T);\n      } catch (e) {\n        reject(new Error('Invalid JSON'));\n      }\n    });\n    req.on('error', reject);\n  });\n};\n\n/**\n * Send JSON response\n */\nconst sendJson = (res: http.ServerResponse, statusCode: number, data: unknown) => {\n  res.writeHead(statusCode, { 'Content-Type': 'application/json' });\n  res.end(JSON.stringify(data));\n};\n\n/**\n * Create HTTP server with router\n */\nexport const createHTTPServer = (port = 3000) => {\n  const router = new Router();\n\n  // Health check\n  router.get('/health', (_req, res) => {\n    sendJson(res, 200, { status: 'ok', timestamp: new Date().toISOString() });\n  });\n\n  // Example routes\n  router.get('/api/items', (_req, res) => {\n    sendJson(res, 200, { items: [] });\n  });\n\n  router.get('/api/items/:id', (_req, res, params) => {\n    sendJson(res, 200, { id: params.id, name: 'Item' });\n  });\n\n  router.post('/api/items', async (req, res) => {\n    const body = await parseBody<{ name: string }>(req);\n    sendJson(res, 201, { id: '1', ...body });\n  });\n\n  // Create server\n  const server = http.createServer(async (req, res) => {\n    const url = new URL(req.url || '/', `http://${req.headers.host}`);\n    const method = req.method || 'GET';\n    const path = url.pathname;\n\n    // CORS headers\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n\n    if (method === 'OPTIONS') {\n      res.writeHead(204);\n      res.end();\n      return;\n    }\n\n    const matched = router.match(method, path);\n\n    if (matched) {\n      try {\n        await matched.handler(req, res, matched.params);\n      } catch (error) {\n        console.error('[ERROR]', error);\n        sendJson(res, 500, { error: 'Internal Server Error' });\n      }\n    } else {\n      sendJson(res, 404, { error: 'Not Found' });\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`HTTP server running on http://localhost:${port}`);\n  });\n\n  return { server, router };\n};\n\n/**\n * Start the server\n */\nif (require.main === module) {\n  createHTTPServer();\n}\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "libs/servers",
    "type": "snippet"
  },
  {
    "name": "socket-server",
    "description": "Socket.io server setup with optional JWT authentication",
    "dependencies": [
      "socket.io",
      "jsonwebtoken"
    ],
    "devDependencies": [
      "@types/jsonwebtoken"
    ],
    "files": [
      {
        "name": "libs/socket.server.ts",
        "path": "libs/socket.server.ts",
        "content": "import { Server, Socket } from \"socket.io\";\nimport jwt from \"jsonwebtoken\";\nimport type { Server as HTTPServer } from \"http\";\n\ninterface JwtPayloadOptions {\n  id: string;\n  email: string;\n  name: string;\n}\n\nexport interface AuthenticatedSocket extends Socket {\n  user?: JwtPayloadOptions;\n}\n\ninterface InitSocketOptions {\n  /** The HTTP server instance to attach socket.io to */\n  server: HTTPServer;\n  /**\n   * Allowed CORS origins\n   * @default \"*\"\n   */\n  allowedOrigins?: string | string[];\n  /**\n   * Allowed HTTP methods for CORS\n   * @default [\"GET\", \"POST\"]\n   */\n  allowedMethods?: string[];\n  /** Allowed headers for CORS */\n  allowedHeaders?: string[];\n  /**\n   * Whether to validate JWT token on connection handshake\n   * @default true\n   */\n  validateToken?: boolean;\n}\n\nexport function initializeSocket({\n  server,\n  allowedOrigins = \"*\",\n  allowedMethods = [\"GET\", \"POST\"],\n  allowedHeaders,\n  validateToken = true,\n}: InitSocketOptions): Server {\n  const io = new Server(server, {\n    cors: {\n      origin: allowedOrigins,\n      methods: allowedMethods,\n      allowedHeaders,\n      credentials: true,\n    },\n  });\n\n  io.use((socket: AuthenticatedSocket, next) => {\n    console.log(\n      `[${new Date().toISOString()}] Socket connected: ${socket.id}, ` +\n        `IP: ${socket.handshake.address}, ` +\n        `Transport: ${socket.conn.transport}`\n    );\n\n    // If validation is disabled, skip auth check\n    if (!validateToken) return next();\n\n    const token = socket.handshake.query.token as string;\n    if (!token) return next(new Error(\"Authentication error\"));\n\n    try {\n      const secret: jwt.Secret = process.env.JWT_ACCESS_SECRET!;\n      const decoded = jwt.verify(token, secret) as JwtPayloadOptions;\n      socket.user = decoded;\n      next();\n    } catch (err) {\n      console.error(\"JWT verification failed:\", err);\n      next(new Error(\"Authentication error\"));\n    }\n  });\n\n  return io;\n}\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "libs/servers",
    "type": "snippet"
  },
  {
    "name": "trpc-server",
    "description": "tRPC server setup with Express adapter",
    "dependencies": [
      "@trpc/server",
      "zod"
    ],
    "devDependencies": [
      "@types/node",
      "@types/express"
    ],
    "files": [
      {
        "name": "libs/servers/trpc-server.ts",
        "path": "libs/servers/trpc-server.ts",
        "content": "import { initTRPC, TRPCError } from '@trpc/server';\nimport { createExpressMiddleware } from '@trpc/server/adapters/express';\nimport express from 'express';\nimport { z } from 'zod';\n\n/**\n * Context creation function\n * Called for each request, provides context to all procedures\n */\nconst createContext = ({ req, res }: { req: express.Request; res: express.Response }) => {\n  // Extract user from auth header if present\n  // const token = req.headers.authorization?.split(' ')[1];\n  // const user = token ? verifyToken(token) : null;\n  \n  return {\n    req,\n    res,\n    // user,\n  };\n};\n\ntype Context = Awaited<ReturnType<typeof createContext>>;\n\n/**\n * Initialize tRPC with context\n */\nconst t = initTRPC.context<Context>().create({\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        // Add custom error data here\n      },\n    };\n  },\n});\n\n/**\n * Reusable middleware\n */\nconst isAuthenticated = t.middleware(({ ctx, next }) => {\n  // if (!ctx.user) {\n  //   throw new TRPCError({ code: 'UNAUTHORIZED' });\n  // }\n  return next({\n    ctx: {\n      ...ctx,\n      // user: ctx.user,\n    },\n  });\n});\n\n/**\n * Procedure builders\n */\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\nexport const protectedProcedure = t.procedure.use(isAuthenticated);\n\n/**\n * Example router with procedures\n */\nconst appRouter = router({\n  // Health check\n  health: publicProcedure.query(() => ({\n    status: 'ok',\n    timestamp: new Date().toISOString(),\n  })),\n\n  // Example public procedure\n  hello: publicProcedure\n    .input(z.object({ name: z.string().optional() }))\n    .query(({ input }) => {\n      return { greeting: `Hello ${input.name || 'World'}!` };\n    }),\n\n  // Example mutation\n  createItem: publicProcedure\n    .input(z.object({\n      title: z.string().min(1).max(100),\n      description: z.string().optional(),\n    }))\n    .mutation(async ({ input }) => {\n      // Save to database\n      const item = {\n        id: Math.random().toString(36).slice(2),\n        ...input,\n        createdAt: new Date(),\n      };\n      return item;\n    }),\n\n  // Nested routers\n  user: router({\n    list: publicProcedure.query(() => {\n      return [{ id: '1', name: 'John' }];\n    }),\n    byId: publicProcedure\n      .input(z.object({ id: z.string() }))\n      .query(({ input }) => {\n        return { id: input.id, name: 'John' };\n      }),\n  }),\n});\n\n/**\n * Export type for client usage\n */\nexport type AppRouter = typeof appRouter;\n\n/**\n * Create and start tRPC server with Express\n */\nexport const createTRPCServer = (port = 4000) => {\n  const app = express();\n\n  // Health check endpoint\n  app.get('/health', (_req, res) => {\n    res.json({ status: 'ok', timestamp: new Date().toISOString() });\n  });\n\n  // tRPC middleware\n  app.use(\n    '/trpc',\n    createExpressMiddleware({\n      router: appRouter,\n      createContext,\n      onError({ error, path }) {\n        console.error(`[ERROR] tRPC error on ${path}:`, error.message);\n      },\n    })\n  );\n\n  const server = app.listen(port, () => {\n    console.log(`tRPC server running at http://localhost:${port}/trpc`);\n  });\n\n  return { app, server, router: appRouter };\n};\n\n/**\n * Start the server\n */\nif (require.main === module) {\n  createTRPCServer();\n}\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "libs/servers",
    "type": "snippet"
  },
  {
    "name": "upload-multer",
    "description": "File upload configuration using Multer",
    "dependencies": [
      "multer"
    ],
    "devDependencies": [
      "@types/multer"
    ],
    "files": [
      {
        "name": "config/upload.ts",
        "path": "config/upload.ts",
        "content": "import multer from 'multer';\nimport path from 'path';\n\n// Configure storage\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) => {\n    cb(null, 'uploads/'); // Ensure this directory exists\n  },\n  filename: (req, file, cb) => {\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);\n    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\n  },\n});\n\n// File filter (optional)\nconst fileFilter = (req: any, file: Express.Multer.File, cb: multer.FileFilterCallback) => {\n  if (file.mimetype.startsWith('image/')) {\n    cb(null, true);\n  } else {\n    cb(new Error('Only image files are allowed!'));\n  }\n};\n\nexport const upload = multer({ \n  storage: storage,\n  fileFilter: fileFilter,\n  limits: {\n    fileSize: 5 * 1024 * 1024, // 5MB limit\n  }\n});\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "libs",
    "type": "snippet"
  },
  {
    "name": "api-key-auth",
    "description": "API Key authentication middleware for service-to-service communication",
    "dependencies": [],
    "devDependencies": [
      "@types/express"
    ],
    "files": [
      {
        "name": "middleware/auth/api-key-auth.ts",
        "path": "middleware/auth/api-key-auth.ts",
        "content": "import { Request, Response, NextFunction } from 'express';\nimport { timingSafeEqual } from 'crypto';\n\n/**\n * API Key configuration\n * In production, load these from environment variables or a database\n */\nconst API_KEYS: Record<string, ApiKeyConfig> = {\n  // Example: 'your-api-key-here': { name: 'Service A', permissions: ['read', 'write'] }\n};\n\n// Load from environment if available\nconst ENV_API_KEY = process.env.API_KEY;\nif (ENV_API_KEY) {\n  API_KEYS[ENV_API_KEY] = { name: 'default', permissions: ['read', 'write'] };\n}\n\ninterface ApiKeyConfig {\n  name: string;\n  permissions: string[];\n  rateLimit?: number;\n}\n\nexport interface ApiKeyRequest extends Request {\n  apiKey?: ApiKeyConfig;\n}\n\n/**\n * Constant-time string comparison to prevent timing attacks\n */\nconst safeCompare = (a: string, b: string): boolean => {\n  if (a.length !== b.length) return false;\n  \n  try {\n    return timingSafeEqual(Buffer.from(a), Buffer.from(b));\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Extract API key from request\n * Supports: X-API-Key header, Authorization header, or query parameter\n */\nconst extractApiKey = (req: Request): string | null => {\n  // Check X-API-Key header (preferred)\n  const headerKey = req.headers['x-api-key'];\n  if (typeof headerKey === 'string') return headerKey;\n  \n  // Check Authorization header with \"ApiKey\" scheme\n  const authHeader = req.headers.authorization;\n  if (authHeader?.startsWith('ApiKey ')) {\n    return authHeader.slice(7);\n  }\n  \n  // Check query parameter (not recommended for production)\n  const queryKey = req.query.api_key;\n  if (typeof queryKey === 'string') return queryKey;\n  \n  return null;\n};\n\n/**\n * Validate API key against known keys\n */\nconst validateApiKey = (key: string): ApiKeyConfig | null => {\n  for (const [validKey, config] of Object.entries(API_KEYS)) {\n    if (safeCompare(key, validKey)) {\n      return config;\n    }\n  }\n  return null;\n};\n\n/**\n * API Key Authentication Middleware\n * Validates API key and attaches config to req.apiKey\n */\nexport const apiKeyAuth = (\n  req: ApiKeyRequest,\n  res: Response,\n  next: NextFunction\n) => {\n  const key = extractApiKey(req);\n\n  if (!key) {\n    return res.status(401).json({\n      success: false,\n      message: 'API key required. Provide via X-API-Key header.',\n    });\n  }\n\n  const config = validateApiKey(key);\n\n  if (!config) {\n    return res.status(401).json({\n      success: false,\n      message: 'Invalid API key.',\n    });\n  }\n\n  req.apiKey = config;\n  next();\n};\n\n/**\n * Permission check middleware\n * Use after apiKeyAuth middleware\n * @param requiredPermissions - Permissions needed to access the route\n */\nexport const requirePermissions = (...requiredPermissions: string[]) => {\n  return (req: ApiKeyRequest, res: Response, next: NextFunction) => {\n    if (!req.apiKey) {\n      return res.status(401).json({\n        success: false,\n        message: 'API key authentication required.',\n      });\n    }\n\n    const hasAllPermissions = requiredPermissions.every(\n      (perm) => req.apiKey!.permissions.includes(perm)\n    );\n\n    if (!hasAllPermissions) {\n      return res.status(403).json({\n        success: false,\n        message: 'Insufficient permissions.',\n        required: requiredPermissions,\n      });\n    }\n\n    next();\n  };\n};\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware/auth",
    "type": "snippet"
  },
  {
    "name": "jwt-auth",
    "description": "JWT authentication middleware for protecting routes",
    "dependencies": [
      "jsonwebtoken"
    ],
    "devDependencies": [
      "@types/jsonwebtoken",
      "@types/express"
    ],
    "files": [
      {
        "name": "middleware/auth/jwt-auth.ts",
        "path": "middleware/auth/jwt-auth.ts",
        "content": "import { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'changeme-in-production';\n\n/**\n * Extended Request interface with user payload\n */\nexport interface AuthenticatedRequest extends Request {\n  user?: JwtPayload;\n}\n\nexport interface JwtPayload {\n  id: string;\n  email: string;\n  role?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Extract JWT token from Authorization header\n * Supports: \"Bearer <token>\" format\n */\nconst extractToken = (req: Request): string | null => {\n  const authHeader = req.headers.authorization;\n  \n  if (!authHeader) return null;\n  \n  // Support \"Bearer <token>\" format\n  if (authHeader.startsWith('Bearer ')) {\n    return authHeader.slice(7);\n  }\n  \n  return authHeader;\n};\n\n/**\n * JWT Authentication Middleware\n * Verifies token and attaches decoded payload to req.user\n */\nexport const authenticate = (\n  req: AuthenticatedRequest,\n  res: Response,\n  next: NextFunction\n) => {\n  const token = extractToken(req);\n\n  if (!token) {\n    return res.status(401).json({\n      success: false,\n      message: 'Access denied. No token provided.',\n    });\n  }\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET) as JwtPayload;\n    req.user = decoded;\n    next();\n  } catch (error) {\n    if (error instanceof jwt.TokenExpiredError) {\n      return res.status(401).json({\n        success: false,\n        message: 'Token has expired.',\n      });\n    }\n    if (error instanceof jwt.JsonWebTokenError) {\n      return res.status(401).json({\n        success: false,\n        message: 'Invalid token.',\n      });\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Failed to authenticate token.',\n    });\n  }\n};\n\n/**\n * Optional authentication - doesn't fail if no token provided\n * Useful for routes that behave differently for logged-in users\n */\nexport const optionalAuth = (\n  req: AuthenticatedRequest,\n  res: Response,\n  next: NextFunction\n) => {\n  const token = extractToken(req);\n\n  if (!token) {\n    return next();\n  }\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET) as JwtPayload;\n    req.user = decoded;\n  } catch {\n    // Token invalid, but that's okay for optional auth\n  }\n  \n  next();\n};\n\n/**\n * Role-based authorization middleware\n * Use after authenticate middleware\n * @param allowedRoles - Array of roles that can access the route\n */\nexport const authorize = (...allowedRoles: string[]) => {\n  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        message: 'Authentication required.',\n      });\n    }\n\n    if (!req.user.role || !allowedRoles.includes(req.user.role)) {\n      return res.status(403).json({\n        success: false,\n        message: 'Insufficient permissions.',\n      });\n    }\n\n    next();\n  };\n};\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware/auth",
    "type": "snippet"
  },
  {
    "name": "error-middleware",
    "description": "Error handling and 404 middleware for Express",
    "dependencies": [],
    "devDependencies": [
      "@types/express"
    ],
    "files": [
      {
        "name": "middleware/error.ts",
        "path": "middleware/error.ts",
        "content": "import { Request, Response, NextFunction } from \"express\";\n\nexport const errorHandler = (\n  err: Error,\n  _req: Request,\n  res: Response,\n  _next: NextFunction\n) => {\n  console.error(\"[ERROR]\", err.stack || err.message);\n  res.status(500).json({\n    success: false,\n    message:\n      process.env.NODE_ENV === \"development\"\n        ? err.message\n        : \"Internal Server Error\",\n  });\n};\n\nexport const notFoundHandler = (req: Request, res: Response) => {\n  res.status(404).json({\n    success: false,\n    message: \"Resource not found\",\n    path: req.originalUrl,\n  });\n};"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware",
    "type": "snippet"
  },
  {
    "name": "routes-logger",
    "description": "Utility to log all registered Express routes on startup",
    "dependencies": [],
    "devDependencies": [
      "@types/express"
    ],
    "files": [
      {
        "name": "middleware/routes-logger.ts",
        "path": "middleware/routes-logger.ts",
        "content": "import type { Express } from \"express\";\n\n/** Normalize and clean Express regex paths */\nconst cleanPath = (path: string): string => {\n  return (\n    path\n      // Remove Express-specific regex tokens\n      .replace(/\\\\\\//g, \"/\")\n      .replace(/\\(\\?:\\^\\)\\?/g, \"\")\n      .replace(/\\(\\?=\\\\\\/\\|\\$\\)/g, \"\")\n      .replace(/\\/\\?\\(\\?=\\/\\|\\$\\)/g, \"\") // <- removes /?(?=/|$)\n      .replace(/\\^\\?/g, \"\")\n      .replace(/\\$$/g, \"\")\n      // Collapse multiple slashes\n      .replace(/\\/{2,}/g, \"/\")\n      // Ensure leading slash\n      .replace(/^(?!\\/)/, \"/\")\n      // Remove trailing slash (except root)\n      .replace(/\\/$/, \"\")\n  );\n};\n\nexport const logRoutes = (app: Express) => {\n  const routes: { method: string; path: string }[] = [];\n\n  const extractRoutes = (stack: any, basePath = \"\") => {\n    stack.forEach((layer: any) => {\n      if (layer.route) {\n        const methods = Object.keys(layer.route.methods).map((m) =>\n          m.toUpperCase()\n        );\n        const fullPath = cleanPath(basePath + layer.route.path);\n        methods.forEach((method) => routes.push({ method, path: fullPath }));\n      } else if (layer.name === \"router\" && layer.handle.stack) {\n        const match = layer.regexp?.source ?? \"\";\n        const prefix = cleanPath(\n          match.replace(\"^\\\\\", \"/\").replace(\"\\\\/?(?=\\\\/|$)\", \"\")\n        );\n        extractRoutes(layer.handle.stack, basePath + prefix);\n      }\n    });\n  };\n\n  extractRoutes(app._router.stack);\n\n  console.log(\"Registered Routes:\");\n  routes.forEach((r) => console.log(`${r.method.padEnd(6)} ${r.path}`));\n};"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware/loggers",
    "type": "snippet"
  },
  {
    "name": "winston-logger",
    "description": "Configurable logger using Winston",
    "dependencies": [
      "winston",
      "morgan"
    ],
    "devDependencies": [
      "@types/node",
      "@types/morgan"
    ],
    "files": [
      {
        "name": "logger.ts",
        "path": "logger.ts",
        "content": "\nimport winston from \"winston\";\nimport morgan from \"morgan\";\n\nconst levels = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  http: 3,\n  debug: 4,\n};\n\nconst level = () => {\n  const env = process.env.NODE_ENV || \"development\";\n  const isDevelopment = env === \"development\";\n  return isDevelopment ? \"debug\" : \"warn\";\n};\n\nconst colors = {\n  error: \"red\",\n  warn: \"yellow\",\n  info: \"green\",\n  http: \"magenta\",\n  debug: \"white\",\n};\n\nwinston.addColors(colors);\n\nconst format = winston.format.combine(\n  winston.format.timestamp({ format: \"YYYY-MM-DD HH:mm:ss:ms\" }),\n  winston.format.colorize({ all: true }),\n  winston.format.printf(\n    (info) => `${info.timestamp} ${info.level}: ${info.message}`\n  )\n);\n\nconst transports = [\n  new winston.transports.Console(),\n  // Add File transport if needed for production\n  // new winston.transports.File({\n  //   filename: 'logs/error.log',\n  //   level: 'error',\n  // }),\n  // new winston.transports.File({ filename: 'logs/all.log' }),\n];\n\nexport const logger = winston.createLogger({\n  level: level(),\n  levels,\n  format,\n  transports,\n});\n\nexport const apiLogger = morgan(\n  \":method :url :status :res[content-length] - :response-time ms\",\n  {\n    stream: {\n      write: (message) => logger.http(message.trim()),\n    },\n  }\n);\n\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware/loggers",
    "type": "snippet"
  },
  {
    "name": "helmet-security",
    "description": "Security headers middleware using Helmet",
    "dependencies": [
      "helmet"
    ],
    "devDependencies": [
      "@types/express"
    ],
    "files": [
      {
        "name": "middleware/security/helmet.ts",
        "path": "middleware/security/helmet.ts",
        "content": "import helmet from 'helmet';\nimport { RequestHandler } from 'express';\n\n/**\n * Production-ready security headers configuration\n * Customize based on your application's needs\n */\nexport const securityHeaders: RequestHandler = helmet({\n  // Content Security Policy - adjust for your needs\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"], // Allow inline styles if needed\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\"],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"],\n      upgradeInsecureRequests: [],\n    },\n  },\n  \n  // Strict Transport Security - force HTTPS\n  hsts: {\n    maxAge: 31536000, // 1 year\n    includeSubDomains: true,\n    preload: true,\n  },\n  \n  // Prevent clickjacking\n  frameguard: {\n    action: 'deny',\n  },\n  \n  // Prevent MIME type sniffing\n  noSniff: true,\n  \n  // XSS Protection (legacy browsers)\n  xssFilter: true,\n  \n  // Hide X-Powered-By header\n  hidePoweredBy: true,\n  \n  // Referrer Policy\n  referrerPolicy: {\n    policy: 'strict-origin-when-cross-origin',\n  },\n  \n  // Permissions Policy (formerly Feature Policy)\n  permittedCrossDomainPolicies: {\n    permittedPolicies: 'none',\n  },\n});\n\n/**\n * Relaxed security headers for development\n * DO NOT use in production!\n */\nexport const devSecurityHeaders: RequestHandler = helmet({\n  contentSecurityPolicy: false, // Disable CSP for easier development\n  hsts: false, // Don't force HTTPS in development\n});\n\n/**\n * API-specific security headers (no CSP needed)\n */\nexport const apiSecurityHeaders: RequestHandler = helmet({\n  contentSecurityPolicy: false, // APIs don't serve HTML\n  frameguard: false, // Not applicable for APIs\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n  },\n});\n\n/**\n * Get appropriate security headers based on environment\n */\nexport const getSecurityHeaders = (): RequestHandler => {\n  const env = process.env.NODE_ENV || 'development';\n  return env === 'production' ? securityHeaders : devSecurityHeaders;\n};\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware/security",
    "type": "snippet"
  },
  {
    "name": "rate-limiter",
    "description": "Rate limiting middleware to prevent brute-force and DDoS attacks",
    "dependencies": [
      "express-rate-limit"
    ],
    "devDependencies": [
      "@types/express"
    ],
    "files": [
      {
        "name": "middleware/security/rate-limiter.ts",
        "path": "middleware/security/rate-limiter.ts",
        "content": "import rateLimit, { RateLimitRequestHandler } from 'express-rate-limit';\nimport { Request, Response } from 'express';\n\n/**\n * Default rate limiter for general API endpoints\n * 100 requests per 15 minutes per IP\n */\nexport const defaultLimiter: RateLimitRequestHandler = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100,\n  message: {\n    success: false,\n    message: 'Too many requests, please try again later.',\n  },\n  standardHeaders: true, // Return rate limit info in `RateLimit-*` headers\n  legacyHeaders: false,  // Disable `X-RateLimit-*` headers\n  keyGenerator: (req: Request) => {\n    // Use X-Forwarded-For for proxied requests, fallback to IP\n    return (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() \n      || req.ip \n      || 'unknown';\n  },\n});\n\n/**\n * Strict rate limiter for authentication endpoints\n * 5 attempts per 15 minutes per IP\n */\nexport const authLimiter: RateLimitRequestHandler = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5,\n  message: {\n    success: false,\n    message: 'Too many login attempts, please try again after 15 minutes.',\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n  skipSuccessfulRequests: true, // Don't count successful logins\n  keyGenerator: (req: Request) => {\n    return (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() \n      || req.ip \n      || 'unknown';\n  },\n});\n\n/**\n * API rate limiter for external API consumers\n * 1000 requests per hour per API key or IP\n */\nexport const apiLimiter: RateLimitRequestHandler = rateLimit({\n  windowMs: 60 * 60 * 1000, // 1 hour\n  max: 1000,\n  message: {\n    success: false,\n    message: 'API rate limit exceeded. Please try again later.',\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n  keyGenerator: (req: Request) => {\n    // Use API key if available, otherwise fall back to IP\n    const apiKey = req.headers['x-api-key'];\n    if (typeof apiKey === 'string') return apiKey;\n    \n    return (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() \n      || req.ip \n      || 'unknown';\n  },\n});\n\n/**\n * Create a custom rate limiter with specific options\n */\nexport const createLimiter = (options: {\n  windowMs: number;\n  max: number;\n  message?: string;\n  keyGenerator?: (req: Request) => string;\n}): RateLimitRequestHandler => {\n  return rateLimit({\n    windowMs: options.windowMs,\n    max: options.max,\n    message: {\n      success: false,\n      message: options.message || 'Too many requests.',\n    },\n    standardHeaders: true,\n    legacyHeaders: false,\n    keyGenerator: options.keyGenerator || ((req: Request) => {\n      return (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() \n        || req.ip \n        || 'unknown';\n    }),\n  });\n};\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware/security",
    "type": "snippet"
  },
  {
    "name": "sanitize-input",
    "description": "Input sanitization middleware to prevent XSS attacks",
    "dependencies": [
      "sanitize-html"
    ],
    "devDependencies": [
      "@types/sanitize-html",
      "@types/express"
    ],
    "files": [
      {
        "name": "middleware/security/sanitize.ts",
        "path": "middleware/security/sanitize.ts",
        "content": "import { Request, Response, NextFunction } from 'express';\nimport sanitizeHtml from 'sanitize-html';\n\n/**\n * Sanitization options\n * Strips all HTML by default - adjust based on your needs\n */\nconst strictOptions: sanitizeHtml.IOptions = {\n  allowedTags: [],\n  allowedAttributes: {},\n  disallowedTagsMode: 'discard',\n};\n\n/**\n * Allow basic formatting tags (for rich text fields)\n */\nconst richTextOptions: sanitizeHtml.IOptions = {\n  allowedTags: ['b', 'i', 'u', 'em', 'strong', 'a', 'p', 'br', 'ul', 'ol', 'li'],\n  allowedAttributes: {\n    a: ['href', 'title', 'target'],\n  },\n  allowedSchemes: ['http', 'https', 'mailto'],\n};\n\n/**\n * Recursively sanitize all string values in an object\n */\nconst sanitizeObject = (\n  obj: unknown,\n  options: sanitizeHtml.IOptions = strictOptions\n): unknown => {\n  if (typeof obj === 'string') {\n    return sanitizeHtml(obj, options).trim();\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map((item) => sanitizeObject(item, options));\n  }\n\n  if (obj !== null && typeof obj === 'object') {\n    const sanitized: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(obj)) {\n      sanitized[key] = sanitizeObject(value, options);\n    }\n    return sanitized;\n  }\n\n  return obj;\n};\n\n/**\n * Strict sanitization middleware\n * Removes ALL HTML tags from request body, query, and params\n */\nexport const sanitizeStrict = (\n  req: Request,\n  _res: Response,\n  next: NextFunction\n) => {\n  if (req.body) {\n    req.body = sanitizeObject(req.body, strictOptions);\n  }\n  if (req.query) {\n    req.query = sanitizeObject(req.query, strictOptions) as typeof req.query;\n  }\n  if (req.params) {\n    req.params = sanitizeObject(req.params, strictOptions) as typeof req.params;\n  }\n  next();\n};\n\n/**\n * Rich text sanitization middleware\n * Allows basic formatting tags but strips dangerous content\n */\nexport const sanitizeRichText = (\n  req: Request,\n  _res: Response,\n  next: NextFunction\n) => {\n  if (req.body) {\n    req.body = sanitizeObject(req.body, richTextOptions);\n  }\n  next();\n};\n\n/**\n * Sanitize specific fields only\n * @param fields - Array of field names to sanitize in request body\n * @param allowRichText - If true, allows basic formatting tags\n */\nexport const sanitizeFields = (fields: string[], allowRichText = false) => {\n  const options = allowRichText ? richTextOptions : strictOptions;\n\n  return (req: Request, _res: Response, next: NextFunction) => {\n    if (req.body && typeof req.body === 'object') {\n      for (const field of fields) {\n        if (field in req.body && typeof req.body[field] === 'string') {\n          req.body[field] = sanitizeHtml(req.body[field], options).trim();\n        }\n      }\n    }\n    next();\n  };\n};\n\n/**\n * Utility function for manual sanitization\n */\nexport const sanitize = (\n  input: string,\n  allowRichText = false\n): string => {\n  const options = allowRichText ? richTextOptions : strictOptions;\n  return sanitizeHtml(input, options).trim();\n};\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware/security",
    "type": "snippet"
  },
  {
    "name": "async-handler",
    "description": "Async/await wrapper to eliminate try-catch boilerplate in route handlers",
    "dependencies": [],
    "devDependencies": [
      "@types/express"
    ],
    "files": [
      {
        "name": "middleware/utils/async-handler.ts",
        "path": "middleware/utils/async-handler.ts",
        "content": "import { Request, Response, NextFunction, RequestHandler } from 'express';\n\n/**\n * Type for async request handlers\n */\ntype AsyncRequestHandler = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => Promise<unknown>;\n\n/**\n * Wraps an async route handler to automatically catch and forward errors\n * Eliminates the need for try-catch blocks in every route\n * \n * @example\n * // Instead of:\n * router.get('/users', async (req, res, next) => {\n *   try {\n *     const users = await User.findAll();\n *     res.json(users);\n *   } catch (err) {\n *     next(err);\n *   }\n * });\n * \n * // You can write:\n * router.get('/users', asyncHandler(async (req, res) => {\n *   const users = await User.findAll();\n *   res.json(users);\n * }));\n */\nexport const asyncHandler = (fn: AsyncRequestHandler): RequestHandler => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n};\n\n/**\n * Alternative syntax using higher-order function\n * Can be used as a decorator-like pattern\n * \n * @example\n * const getUsers = catchAsync(async (req, res) => {\n *   const users = await User.findAll();\n *   res.json(users);\n * });\n * \n * router.get('/users', getUsers);\n */\nexport const catchAsync = asyncHandler; // Alias for those who prefer this name\n\n/**\n * Wrap multiple handlers at once\n * \n * @example\n * const [getUser, createUser, deleteUser] = wrapHandlers(\n *   async (req, res) => { ... },\n *   async (req, res) => { ... },\n *   async (req, res) => { ... },\n * );\n */\nexport const wrapHandlers = (\n  ...handlers: AsyncRequestHandler[]\n): RequestHandler[] => {\n  return handlers.map(asyncHandler);\n};\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware/utils",
    "type": "snippet"
  },
  {
    "name": "cache-control",
    "description": "Cache control middleware for setting HTTP caching headers",
    "dependencies": [],
    "devDependencies": [
      "@types/express"
    ],
    "files": [
      {
        "name": "middleware/utils/cache-control.ts",
        "path": "middleware/utils/cache-control.ts",
        "content": "import { Request, Response, NextFunction, RequestHandler } from 'express';\n\n/**\n * Cache control options\n */\ninterface CacheOptions {\n  /** Max age in seconds */\n  maxAge?: number;\n  /** Whether the response can be cached by shared caches (CDNs) */\n  public?: boolean;\n  /** Whether to add must-revalidate directive */\n  mustRevalidate?: boolean;\n  /** S-maxage for shared caches (CDNs) */\n  sMaxAge?: number;\n  /** Stale-while-revalidate in seconds */\n  staleWhileRevalidate?: number;\n  /** Stale-if-error in seconds */\n  staleIfError?: number;\n}\n\n/**\n * Build Cache-Control header value from options\n */\nconst buildCacheControl = (options: CacheOptions): string => {\n  const directives: string[] = [];\n\n  if (options.public) {\n    directives.push('public');\n  } else {\n    directives.push('private');\n  }\n\n  if (options.maxAge !== undefined) {\n    directives.push(`max-age=${options.maxAge}`);\n  }\n\n  if (options.sMaxAge !== undefined) {\n    directives.push(`s-maxage=${options.sMaxAge}`);\n  }\n\n  if (options.mustRevalidate) {\n    directives.push('must-revalidate');\n  }\n\n  if (options.staleWhileRevalidate !== undefined) {\n    directives.push(`stale-while-revalidate=${options.staleWhileRevalidate}`);\n  }\n\n  if (options.staleIfError !== undefined) {\n    directives.push(`stale-if-error=${options.staleIfError}`);\n  }\n\n  return directives.join(', ');\n};\n\n/**\n * Create cache control middleware with custom options\n */\nexport const cacheControl = (options: CacheOptions): RequestHandler => {\n  const headerValue = buildCacheControl(options);\n\n  return (_req: Request, res: Response, next: NextFunction) => {\n    res.setHeader('Cache-Control', headerValue);\n    next();\n  };\n};\n\n/**\n * No cache - for sensitive or dynamic content\n * Prevents all caching\n */\nexport const noCache: RequestHandler = (_req, res, next) => {\n  res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');\n  res.setHeader('Pragma', 'no-cache');\n  res.setHeader('Expires', '0');\n  next();\n};\n\n/**\n * Short cache - for frequently updated content\n * 5 minutes browser, 1 minute CDN\n */\nexport const shortCache: RequestHandler = cacheControl({\n  public: true,\n  maxAge: 300, // 5 minutes\n  sMaxAge: 60, // 1 minute for CDN\n  staleWhileRevalidate: 60,\n});\n\n/**\n * Medium cache - for semi-static content\n * 1 hour browser, 30 minutes CDN\n */\nexport const mediumCache: RequestHandler = cacheControl({\n  public: true,\n  maxAge: 3600, // 1 hour\n  sMaxAge: 1800, // 30 minutes for CDN\n  staleWhileRevalidate: 300,\n  staleIfError: 86400, // 1 day fallback on errors\n});\n\n/**\n * Long cache - for static assets\n * 1 year (use with versioned/hashed filenames)\n */\nexport const longCache: RequestHandler = cacheControl({\n  public: true,\n  maxAge: 31536000, // 1 year\n  mustRevalidate: false,\n});\n\n/**\n * Immutable cache - for content that never changes\n * Use with content-addressable URLs (hash in filename)\n */\nexport const immutableCache: RequestHandler = (_req, res, next) => {\n  res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');\n  next();\n};\n\n/**\n * Private cache - for user-specific content\n * Cached in browser only, not in CDNs\n */\nexport const privateCache: RequestHandler = cacheControl({\n  public: false,\n  maxAge: 3600, // 1 hour\n  mustRevalidate: true,\n});\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware/utils",
    "type": "snippet"
  },
  {
    "name": "compression",
    "description": "Response compression middleware for gzip/brotli",
    "dependencies": [
      "compression"
    ],
    "devDependencies": [
      "@types/compression",
      "@types/express"
    ],
    "files": [
      {
        "name": "middleware/utils/compression.ts",
        "path": "middleware/utils/compression.ts",
        "content": "import compression from 'compression';\nimport { Request, Response, RequestHandler } from 'express';\n\n/**\n * Default compression middleware\n * Compresses responses larger than 1KB using gzip\n */\nexport const compress: RequestHandler = compression({\n  // Only compress responses larger than 1KB\n  threshold: 1024,\n  \n  // Compression level (1-9, higher = more compression but slower)\n  level: 6,\n  \n  // Filter function to decide what to compress\n  filter: (req: Request, res: Response) => {\n    // Don't compress if client doesn't accept it\n    if (req.headers['x-no-compression']) {\n      return false;\n    }\n    \n    // Use compression's default filter (checks Accept-Encoding)\n    return compression.filter(req, res);\n  },\n});\n\n/**\n * Aggressive compression for bandwidth-critical applications\n * Higher compression level, lower threshold\n */\nexport const compressAggressive: RequestHandler = compression({\n  threshold: 512,\n  level: 9,\n  filter: (req: Request, res: Response) => {\n    if (req.headers['x-no-compression']) {\n      return false;\n    }\n    return compression.filter(req, res);\n  },\n});\n\n/**\n * Light compression for CPU-constrained servers\n * Lower compression level, higher threshold\n */\nexport const compressLight: RequestHandler = compression({\n  threshold: 2048,\n  level: 1,\n  filter: (req: Request, res: Response) => {\n    if (req.headers['x-no-compression']) {\n      return false;\n    }\n    return compression.filter(req, res);\n  },\n});\n\n/**\n * Skip compression for specific content types\n * Useful when serving already-compressed content (images, videos)\n */\nexport const compressSelectiveTypes: RequestHandler = compression({\n  threshold: 1024,\n  level: 6,\n  filter: (req: Request, res: Response) => {\n    const contentType = res.getHeader('Content-Type') as string;\n    \n    // Skip already-compressed formats\n    const skipTypes = [\n      'image/',\n      'video/',\n      'audio/',\n      'application/zip',\n      'application/gzip',\n      'application/x-rar',\n    ];\n    \n    if (contentType && skipTypes.some(type => contentType.includes(type))) {\n      return false;\n    }\n    \n    if (req.headers['x-no-compression']) {\n      return false;\n    }\n    \n    return compression.filter(req, res);\n  },\n});\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware/utils",
    "type": "snippet"
  },
  {
    "name": "request-id",
    "description": "Request ID middleware for distributed tracing and logging",
    "dependencies": [
      "uuid"
    ],
    "devDependencies": [
      "@types/uuid",
      "@types/express"
    ],
    "files": [
      {
        "name": "middleware/utils/request-id.ts",
        "path": "middleware/utils/request-id.ts",
        "content": "import { Request, Response, NextFunction } from 'express';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Header names for request ID\n */\nconst REQUEST_ID_HEADER = 'X-Request-ID';\nconst CORRELATION_ID_HEADER = 'X-Correlation-ID';\n\n/**\n * Extended request with ID fields\n */\nexport interface RequestWithId extends Request {\n  id: string;\n  correlationId?: string;\n}\n\n/**\n * Request ID Middleware\n * \n * Generates a unique ID for each request and attaches it to:\n * - req.id (for use in application code)\n * - Response header X-Request-ID (for client correlation)\n * \n * If the client sends X-Request-ID, it will be preserved.\n * If X-Correlation-ID is sent, it's stored for distributed tracing.\n */\nexport const requestId = (\n  req: RequestWithId,\n  res: Response,\n  next: NextFunction\n) => {\n  // Use existing request ID from client or generate new one\n  const existingId = req.headers[REQUEST_ID_HEADER.toLowerCase()] as string;\n  const id = existingId || uuidv4();\n\n  // Store correlation ID if provided (for distributed tracing)\n  const correlationId = req.headers[CORRELATION_ID_HEADER.toLowerCase()] as string;\n\n  // Attach to request object\n  req.id = id;\n  if (correlationId) {\n    req.correlationId = correlationId;\n  }\n\n  // Set response header so client can correlate\n  res.setHeader(REQUEST_ID_HEADER, id);\n  if (correlationId) {\n    res.setHeader(CORRELATION_ID_HEADER, correlationId);\n  }\n\n  next();\n};\n\n/**\n * Get request ID from request object (type-safe)\n */\nexport const getRequestId = (req: Request): string => {\n  return (req as RequestWithId).id || 'unknown';\n};\n\n/**\n * Create a child logger context with request ID\n * Useful for structured logging\n * \n * @example\n * const context = createLogContext(req);\n * logger.info('User logged in', context);\n * // Output: { requestId: '...', correlationId: '...', message: 'User logged in' }\n */\nexport const createLogContext = (req: Request) => {\n  const typedReq = req as RequestWithId;\n  return {\n    requestId: typedReq.id,\n    correlationId: typedReq.correlationId,\n    method: req.method,\n    path: req.path,\n    ip: req.ip,\n  };\n};\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware/utils",
    "type": "snippet"
  },
  {
    "name": "response-time",
    "description": "Response time middleware with headers and optional logging",
    "dependencies": [],
    "devDependencies": [
      "@types/express"
    ],
    "files": [
      {
        "name": "middleware/response-time.ts",
        "path": "middleware/response-time.ts",
        "content": "import { Request, Response, NextFunction, RequestHandler } from 'express';\n\n/**\n * Response time options\n */\ninterface ResponseTimeOptions {\n  /** Header name (default: X-Response-Time) */\n  header?: string;\n  /** Include unit suffix (default: true, e.g., \"12.34ms\") */\n  suffix?: boolean;\n  /** Number of decimal places (default: 2) */\n  digits?: number;\n  /** Enable console logging (default: false in production) */\n  log?: boolean;\n  /** Log slow requests above this threshold in ms (default: 1000) */\n  slowThreshold?: number;\n}\n\n/**\n * Response time middleware\n * - Adds X-Response-Time header (high precision using hrtime)\n * - Optional request/response logging\n * - Slow request warnings\n */\nexport const responseTime = (options: ResponseTimeOptions = {}): RequestHandler => {\n  const {\n    header = 'X-Response-Time',\n    suffix = true,\n    digits = 2,\n    log = process.env.NODE_ENV !== 'production',\n    slowThreshold = 1000,\n  } = options;\n\n  return (req: Request, res: Response, next: NextFunction) => {\n    const start = process.hrtime.bigint();\n    const ip = req.ip || req.socket?.remoteAddress || 'unknown';\n\n    // Log incoming request (only in dev or if explicitly enabled)\n    if (log) {\n      console.log(\n        `[REQ] [${new Date().toISOString()}] ${req.method} ${req.originalUrl} - IP: ${ip}`\n      );\n    }\n\n    res.on('finish', () => {\n      const end = process.hrtime.bigint();\n      const durationNs = Number(end - start);\n      const durationMs = durationNs / 1_000_000;\n\n      const value = suffix\n        ? `${durationMs.toFixed(digits)}ms`\n        : durationMs.toFixed(digits);\n\n      // Set header if not already sent\n      if (!res.headersSent) {\n        res.setHeader(header, value);\n      }\n\n      // Log response (only in dev or if explicitly enabled)\n      if (log) {\n        console.log(\n          `[RES] [${new Date().toISOString()}] ${req.method} ${req.originalUrl} - ${res.statusCode} - ${value}`\n        );\n      }\n\n      // Always warn about slow requests (even in production)\n      if (durationMs > slowThreshold) {\n        console.warn(\n          `Slow request: ${req.method} ${req.originalUrl} took ${value}`\n        );\n      }\n    });\n\n    next();\n  };\n};\n\n/**\n * Default middleware - headers only, no logging in production\n */\nexport const defaultResponseTime: RequestHandler = responseTime();\n\n/**\n * Development middleware - with full logging\n */\nexport const devResponseTime: RequestHandler = responseTime({ log: true });\n\n/**\n * Production middleware - headers only, no logging\n */\nexport const prodResponseTime: RequestHandler = responseTime({ log: false });\n\n/**\n * Server Timing API support\n * Adds Server-Timing header for detailed performance metrics\n * Visible in browser DevTools Network tab\n */\nexport const serverTiming = (): RequestHandler => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const start = process.hrtime.bigint();\n    const timings: string[] = [];\n\n    // Attach method to add custom timings\n    (res as any).timing = (name: string, duration: number, desc?: string) => {\n      timings.push(desc ? `${name};dur=${duration};desc=\"${desc}\"` : `${name};dur=${duration}`);\n    };\n\n    res.on('finish', () => {\n      const totalMs = Number(process.hrtime.bigint() - start) / 1_000_000;\n      timings.unshift(`total;dur=${totalMs.toFixed(2)};desc=\"Total\"`);\n\n      if (!res.headersSent) {\n        res.setHeader('Server-Timing', timings.join(', '));\n      }\n    });\n\n    next();\n  };\n};\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware/utils",
    "type": "snippet"
  },
  {
    "name": "validation-zod",
    "description": "Request validation middleware using Zod",
    "dependencies": [
      "zod"
    ],
    "files": [
      {
        "name": "middleware/validate.ts",
        "path": "middleware/validate.ts",
        "content": "import { Request, Response, NextFunction } from 'express';\nimport { AnyZodObject, ZodError } from 'zod';\n\nexport const validate = (schema: AnyZodObject) => async (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => {\n  try {\n    await schema.parseAsync({\n      body: req.body,\n      query: req.query,\n      params: req.params,\n    });\n    return next();\n  } catch (error) {\n    if (error instanceof ZodError) {\n      return res.status(400).json({\n        success: false,\n        message: 'Validation failed',\n        errors: error.errors,\n      });\n    }\n    return res.status(500).json({ success: false, message: 'Internal server error' });\n  }\n};\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "middleware",
    "type": "snippet"
  },
  {
    "name": "health-check",
    "description": "Health and readiness check endpoints for monitoring",
    "dependencies": [],
    "devDependencies": [
      "@types/express"
    ],
    "files": [
      {
        "name": "routes/health.ts",
        "path": "routes/health.ts",
        "content": "import { Router, Request, Response } from 'express';\n\nconst router = Router();\n\ninterface HealthCheckResult {\n  status: 'healthy' | 'unhealthy';\n  timestamp: string;\n  uptime: number;\n  checks?: Record<string, CheckResult>;\n}\n\ninterface CheckResult {\n  status: 'pass' | 'fail';\n  latency?: number;\n  message?: string;\n}\n\n/**\n * Register health check functions\n * Add your database, cache, external service checks here\n */\nconst healthChecks: Record<string, () => Promise<CheckResult>> = {\n  // Example: Database check\n  // database: async () => {\n  //   const start = Date.now();\n  //   try {\n  //     await prisma.$queryRaw`SELECT 1`;\n  //     return { status: 'pass', latency: Date.now() - start };\n  //   } catch (e) {\n  //     return { status: 'fail', message: (e as Error).message };\n  //   }\n  // },\n  \n  // Example: Redis check\n  // redis: async () => {\n  //   const start = Date.now();\n  //   try {\n  //     await redis.ping();\n  //     return { status: 'pass', latency: Date.now() - start };\n  //   } catch (e) {\n  //     return { status: 'fail', message: (e as Error).message };\n  //   }\n  // },\n};\n\n/**\n * Run all health checks\n */\nconst runHealthChecks = async (): Promise<HealthCheckResult> => {\n  const checks: Record<string, CheckResult> = {};\n  let allHealthy = true;\n\n  for (const [name, check] of Object.entries(healthChecks)) {\n    try {\n      checks[name] = await check();\n      if (checks[name].status === 'fail') {\n        allHealthy = false;\n      }\n    } catch (error) {\n      checks[name] = { status: 'fail', message: (error as Error).message };\n      allHealthy = false;\n    }\n  }\n\n  return {\n    status: allHealthy ? 'healthy' : 'unhealthy',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime(),\n    checks: Object.keys(checks).length > 0 ? checks : undefined,\n  };\n};\n\n/**\n * GET /health\n * Basic health check - returns 200 if server is responding\n * Use for load balancer health probes\n */\nrouter.get('/health', (_req: Request, res: Response) => {\n  res.status(200).json({\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n  });\n});\n\n/**\n * GET /health/live\n * Liveness probe - is the server running?\n * Returns 200 if process is alive\n */\nrouter.get('/health/live', (_req: Request, res: Response) => {\n  res.status(200).json({\n    status: 'alive',\n    uptime: process.uptime(),\n  });\n});\n\n/**\n * GET /health/ready\n * Readiness probe - is the server ready to accept traffic?\n * Checks all dependencies (database, cache, etc.)\n */\nrouter.get('/health/ready', async (_req: Request, res: Response) => {\n  const result = await runHealthChecks();\n  const statusCode = result.status === 'healthy' ? 200 : 503;\n  res.status(statusCode).json(result);\n});\n\n/**\n * GET /health/detailed\n * Detailed health check with all dependency statuses\n * Protected in production (add auth middleware if needed)\n */\nrouter.get('/health/detailed', async (_req: Request, res: Response) => {\n  const result = await runHealthChecks();\n  \n  res.status(result.status === 'healthy' ? 200 : 503).json({\n    ...result,\n    version: process.env.npm_package_version || 'unknown',\n    environment: process.env.NODE_ENV || 'development',\n    memory: {\n      used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),\n      total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024),\n      unit: 'MB',\n    },\n  });\n});\n\nexport default router;\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "routes",
    "type": "snippet"
  },
  {
    "name": "crypto-utils",
    "description": "Encryption and decryption utilities using AES-256-GCM",
    "dependencies": [],
    "files": [
      {
        "name": "utils/crypto.ts",
        "path": "utils/crypto.ts",
        "content": "import {\n  randomBytes,\n  createCipheriv,\n  createDecipheriv,\n  createHash,\n} from 'crypto';\n\n/**\n * Encryption configuration\n * Uses AES-256-GCM (authenticated encryption)\n */\nconst ALGORITHM = 'aes-256-gcm';\nconst IV_LENGTH = 16;\nconst AUTH_TAG_LENGTH = 16;\nconst SALT_LENGTH = 32;\n\n/**\n * Get or generate encryption key from environment\n * Key must be 32 bytes (256 bits) for AES-256\n */\nconst getEncryptionKey = (): Buffer => {\n  const key = process.env.ENCRYPTION_KEY;\n  \n  if (!key) {\n    throw new Error('ENCRYPTION_KEY environment variable is required');\n  }\n  \n  // If key is 64 hex chars (32 bytes), use directly\n  if (/^[a-f0-9]{64}$/i.test(key)) {\n    return Buffer.from(key, 'hex');\n  }\n  \n  // Otherwise, derive a key using SHA-256\n  return createHash('sha256').update(key).digest();\n};\n\n/**\n * Encrypt a string\n * Returns: base64 encoded string containing IV + encrypted data + auth tag\n */\nexport const encrypt = (plaintext: string): string => {\n  const key = getEncryptionKey();\n  const iv = randomBytes(IV_LENGTH);\n  \n  const cipher = createCipheriv(ALGORITHM, key, iv, {\n    authTagLength: AUTH_TAG_LENGTH,\n  });\n  \n  let encrypted = cipher.update(plaintext, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  \n  const authTag = cipher.getAuthTag();\n  \n  // Format: IV (16 bytes) + encrypted data + auth tag (16 bytes)\n  const result = Buffer.concat([\n    iv,\n    Buffer.from(encrypted, 'hex'),\n    authTag,\n  ]);\n  \n  return result.toString('base64');\n};\n\n/**\n * Decrypt a string\n * Input: base64 encoded string from encrypt()\n */\nexport const decrypt = (encrypted: string): string => {\n  const key = getEncryptionKey();\n  const data = Buffer.from(encrypted, 'base64');\n  \n  // Extract components\n  const iv = data.subarray(0, IV_LENGTH);\n  const authTag = data.subarray(data.length - AUTH_TAG_LENGTH);\n  const ciphertext = data.subarray(IV_LENGTH, data.length - AUTH_TAG_LENGTH);\n  \n  const decipher = createDecipheriv(ALGORITHM, key, iv, {\n    authTagLength: AUTH_TAG_LENGTH,\n  });\n  \n  decipher.setAuthTag(authTag);\n  \n  let decrypted = decipher.update(ciphertext);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  \n  return decrypted.toString('utf8');\n};\n\n/**\n * Generate a random hex string\n * @param bytes - Number of random bytes (default: 32 = 64 hex chars)\n */\nexport const generateRandomHex = (bytes = 32): string => {\n  return randomBytes(bytes).toString('hex');\n};\n\n/**\n * Generate a random base64url string (URL-safe)\n * @param bytes - Number of random bytes\n */\nexport const generateRandomBase64 = (bytes = 32): string => {\n  return randomBytes(bytes).toString('base64url');\n};\n\n/**\n * Hash a string with SHA-256\n */\nexport const hashSha256 = (input: string): string => {\n  return createHash('sha256').update(input).digest('hex');\n};\n\n/**\n * Compare two strings in constant time (timing-safe)\n * Use for comparing tokens, hashes, etc.\n */\nexport const secureCompare = (a: string, b: string): boolean => {\n  if (a.length !== b.length) return false;\n  \n  const bufA = Buffer.from(a);\n  const bufB = Buffer.from(b);\n  \n  return require('crypto').timingSafeEqual(bufA, bufB);\n};\n\n/**\n * Encrypt an object (JSON)\n */\nexport const encryptObject = <T>(obj: T): string => {\n  return encrypt(JSON.stringify(obj));\n};\n\n/**\n * Decrypt to object (JSON)\n */\nexport const decryptObject = <T>(encrypted: string): T => {\n  const decrypted = decrypt(encrypted);\n  return JSON.parse(decrypted) as T;\n};\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "utils",
    "type": "snippet"
  },
  {
    "name": "otp-generator",
    "description": "TOTP/HOTP 2FA utilities for authentication",
    "dependencies": [
      "otpauth",
      "qrcode"
    ],
    "devDependencies": [
      "@types/qrcode"
    ],
    "files": [
      {
        "name": "utils/otp.ts",
        "path": "utils/otp.ts",
        "content": "import * as OTPAuth from 'otpauth';\nimport QRCode from 'qrcode';\n\n/**\n * OTP configuration\n */\nconst config = {\n  issuer: process.env.OTP_ISSUER || 'MyApp',\n  algorithm: 'SHA1' as const,\n  digits: 6,\n  period: 30, // seconds\n};\n\n/**\n * Generate a new TOTP secret for a user\n * @param accountName - User identifier (email, username)\n */\nexport const generateSecret = (accountName: string) => {\n  const totp = new OTPAuth.TOTP({\n    issuer: config.issuer,\n    label: accountName,\n    algorithm: config.algorithm,\n    digits: config.digits,\n    period: config.period,\n    secret: new OTPAuth.Secret({ size: 20 }),\n  });\n\n  return {\n    secret: totp.secret.base32,\n    uri: totp.toString(),\n  };\n};\n\n/**\n * Generate QR code as data URL\n * @param uri - OTP Auth URI from generateSecret()\n */\nexport const generateQRCode = async (uri: string): Promise<string> => {\n  return QRCode.toDataURL(uri, {\n    errorCorrectionLevel: 'M',\n    type: 'image/png',\n    width: 256,\n    margin: 2,\n  });\n};\n\n/**\n * Generate QR code as SVG string\n * @param uri - OTP Auth URI from generateSecret()\n */\nexport const generateQRCodeSVG = async (uri: string): Promise<string> => {\n  return QRCode.toString(uri, {\n    type: 'svg',\n    margin: 2,\n  });\n};\n\n/**\n * Verify a TOTP token\n * @param secret - User's stored secret (base32)\n * @param token - Token from authenticator app\n * @param window - Time window to allow (default: 1 = 30 seconds)\n */\nexport const verifyToken = (\n  secret: string,\n  token: string,\n  window = 1\n): boolean => {\n  const totp = new OTPAuth.TOTP({\n    issuer: config.issuer,\n    algorithm: config.algorithm,\n    digits: config.digits,\n    period: config.period,\n    secret: OTPAuth.Secret.fromBase32(secret),\n  });\n\n  // Returns delta (time steps difference) or null if invalid\n  const delta = totp.validate({ token, window });\n  return delta !== null;\n};\n\n/**\n * Generate current TOTP token (for testing)\n * @param secret - User's stored secret (base32)\n */\nexport const generateToken = (secret: string): string => {\n  const totp = new OTPAuth.TOTP({\n    issuer: config.issuer,\n    algorithm: config.algorithm,\n    digits: config.digits,\n    period: config.period,\n    secret: OTPAuth.Secret.fromBase32(secret),\n  });\n\n  return totp.generate();\n};\n\n/**\n * Generate backup codes for account recovery\n * @param count - Number of backup codes (default: 10)\n */\nexport const generateBackupCodes = (count = 10): string[] => {\n  const codes: string[] = [];\n  \n  for (let i = 0; i < count; i++) {\n    // Generate 8-character alphanumeric code\n    const code = Array.from({ length: 8 }, () =>\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.charAt(\n        Math.floor(Math.random() * 36)\n      )\n    ).join('');\n    \n    // Format as XXXX-XXXX for readability\n    codes.push(`${code.slice(0, 4)}-${code.slice(4)}`);\n  }\n  \n  return codes;\n};\n\n/**\n * Example usage:\n * \n * // Setup 2FA\n * const { secret, uri } = generateSecret('user@example.com');\n * const qrCode = await generateQRCode(uri);\n * // Store secret in database, send qrCode to frontend\n * \n * // Verify during login\n * const isValid = verifyToken(user.otpSecret, submittedToken);\n */\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "utils",
    "type": "snippet"
  },
  {
    "name": "pagination",
    "description": "Cursor and offset pagination helpers for database queries",
    "dependencies": [],
    "devDependencies": [
      "@types/express"
    ],
    "files": [
      {
        "name": "utils/pagination.ts",
        "path": "utils/pagination.ts",
        "content": "/**\n * Offset pagination result\n */\nexport interface OffsetPaginationResult<T> {\n  data: T[];\n  meta: {\n    total: number;\n    page: number;\n    perPage: number;\n    totalPages: number;\n    hasNextPage: boolean;\n    hasPrevPage: boolean;\n  };\n}\n\n/**\n * Cursor pagination result\n */\nexport interface CursorPaginationResult<T> {\n  data: T[];\n  meta: {\n    nextCursor: string | null;\n    prevCursor: string | null;\n    hasMore: boolean;\n  };\n}\n\n/**\n * Parse pagination params from request query\n */\nexport const parseOffsetParams = (query: {\n  page?: string;\n  limit?: string;\n  perPage?: string;\n}) => {\n  const page = Math.max(1, parseInt(query.page || '1', 10));\n  const limit = Math.min(100, Math.max(1, parseInt(query.limit || query.perPage || '20', 10)));\n  const offset = (page - 1) * limit;\n\n  return { page, limit, offset };\n};\n\n/**\n * Build offset pagination response\n */\nexport const buildOffsetResponse = <T>(\n  data: T[],\n  total: number,\n  page: number,\n  limit: number\n): OffsetPaginationResult<T> => {\n  const totalPages = Math.ceil(total / limit);\n\n  return {\n    data,\n    meta: {\n      total,\n      page,\n      perPage: limit,\n      totalPages,\n      hasNextPage: page < totalPages,\n      hasPrevPage: page > 1,\n    },\n  };\n};\n\n/**\n * Parse cursor pagination params\n */\nexport const parseCursorParams = (query: {\n  cursor?: string;\n  limit?: string;\n  direction?: 'next' | 'prev';\n}) => {\n  const cursor = query.cursor || null;\n  const limit = Math.min(100, Math.max(1, parseInt(query.limit || '20', 10)));\n  const direction = query.direction || 'next';\n\n  return { cursor, limit, direction };\n};\n\n/**\n * Encode cursor (base64)\n */\nexport const encodeCursor = (value: string | number | Date): string => {\n  const str = value instanceof Date ? value.toISOString() : String(value);\n  return Buffer.from(str).toString('base64url');\n};\n\n/**\n * Decode cursor (base64)\n */\nexport const decodeCursor = (cursor: string): string => {\n  try {\n    return Buffer.from(cursor, 'base64url').toString('utf8');\n  } catch {\n    throw new Error('Invalid cursor');\n  }\n};\n\n/**\n * Build cursor pagination response\n * @param data - Query results (should include +1 extra item to detect hasMore)\n * @param limit - Requested limit\n * @param cursorField - Field to use for cursor (e.g., 'id', 'createdAt')\n */\nexport const buildCursorResponse = <T extends Record<string, unknown>>(\n  data: T[],\n  limit: number,\n  cursorField: keyof T\n): CursorPaginationResult<T> => {\n  const hasMore = data.length > limit;\n  const items = hasMore ? data.slice(0, limit) : data;\n\n  const nextCursor = hasMore && items.length > 0\n    ? encodeCursor(items[items.length - 1][cursorField] as string | number)\n    : null;\n\n  const prevCursor = items.length > 0\n    ? encodeCursor(items[0][cursorField] as string | number)\n    : null;\n\n  return {\n    data: items,\n    meta: {\n      nextCursor,\n      prevCursor,\n      hasMore,\n    },\n  };\n};\n\n/**\n * Example usage with Prisma:\n * \n * const { page, limit, offset } = parseOffsetParams(req.query);\n * \n * const [users, total] = await Promise.all([\n *   prisma.user.findMany({ skip: offset, take: limit }),\n *   prisma.user.count(),\n * ]);\n * \n * res.json(buildOffsetResponse(users, total, page, limit));\n */\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "utils",
    "type": "snippet"
  },
  {
    "name": "slug-generator",
    "description": "URL-safe slug generator with collision handling",
    "dependencies": [
      "slugify"
    ],
    "files": [
      {
        "name": "utils/slug.ts",
        "path": "utils/slug.ts",
        "content": "import slugify from 'slugify';\n\n/**\n * Slugify options\n */\nconst defaultOptions: Parameters<typeof slugify>[1] = {\n  lower: true,\n  strict: true,    // Remove special characters\n  trim: true,\n  locale: 'en',\n};\n\n/**\n * Generate a URL-safe slug from a string\n * @param text - Text to convert to slug\n * @param options - Optional slugify options\n */\nexport const generateSlug = (\n  text: string,\n  options?: Parameters<typeof slugify>[1]\n): string => {\n  return slugify(text, { ...defaultOptions, ...options });\n};\n\n/**\n * Generate a unique slug with random suffix\n * Useful when slug collision is possible\n * @param text - Text to convert to slug\n * @param length - Length of random suffix (default: 6)\n */\nexport const generateUniqueSlug = (text: string, length = 6): string => {\n  const baseSlug = generateSlug(text);\n  const randomSuffix = Math.random()\n    .toString(36)\n    .substring(2, 2 + length);\n  return `${baseSlug}-${randomSuffix}`;\n};\n\n/**\n * Generate slug with timestamp suffix\n * Ensures uniqueness based on creation time\n * @param text - Text to convert to slug\n */\nexport const generateTimestampSlug = (text: string): string => {\n  const baseSlug = generateSlug(text);\n  const timestamp = Date.now().toString(36);\n  return `${baseSlug}-${timestamp}`;\n};\n\n/**\n * Check if a string is a valid slug\n */\nexport const isValidSlug = (slug: string): boolean => {\n  return /^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(slug);\n};\n\n/**\n * Sanitize an existing slug (fix invalid characters)\n */\nexport const sanitizeSlug = (slug: string): string => {\n  return slug\n    .toLowerCase()\n    .replace(/[^a-z0-9-]/g, '-')\n    .replace(/-+/g, '-')\n    .replace(/^-|-$/g, '');\n};\n\n/**\n * Create a unique slug checker function\n * Use with database to ensure uniqueness\n * \n * @example\n * const slugChecker = createSlugChecker(async (slug) => {\n *   const exists = await prisma.post.findUnique({ where: { slug } });\n *   return !!exists;\n * });\n * \n * const uniqueSlug = await slugChecker('my-post-title');\n */\nexport const createSlugChecker = (\n  checkExists: (slug: string) => Promise<boolean>\n) => {\n  return async (text: string, maxAttempts = 10): Promise<string> => {\n    let slug = generateSlug(text);\n    let attempt = 0;\n\n    while (await checkExists(slug)) {\n      attempt++;\n      if (attempt >= maxAttempts) {\n        // Fall back to UUID-based slug\n        slug = generateUniqueSlug(text, 8);\n        break;\n      }\n      slug = `${generateSlug(text)}-${attempt}`;\n    }\n\n    return slug;\n  };\n};\n"
      }
    ],
    "version": "v5",
    "framework": "express",
    "category": "utils",
    "type": "snippet"
  }
]
