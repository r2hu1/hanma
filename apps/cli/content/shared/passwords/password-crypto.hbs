---
name: password-crypto
description: Password hashing using Node.js native crypto (Scrypt) - Zero dependencies
dependencies: []
files:
  - name: utils/password.ts
---
import { scrypt, randomBytes, timingSafeEqual } from 'crypto';
import { promisify } from 'util';

const scryptAsync = promisify(scrypt);

/**
 * Scrypt configuration following security best practices:
 * - Salt length: 32 bytes (256 bits)
 * - Key length: 64 bytes (512 bits)
 * - Cost (N): 2^17 = 131072 (memory and CPU cost)
 * - Block size (r): 8
 * - Parallelization (p): 1
 * 
 * These values provide strong security with ~100ms hashing time.
 */
const SALT_LENGTH = 32;
const KEY_LENGTH = 64;

const SCRYPT_OPTIONS = {
  N: 131072, // CPU/memory cost parameter (2^17)
  r: 8,      // Block size
  p: 1,      // Parallelization
  maxmem: 256 * 1024 * 1024, // 256 MiB max memory
};

// Hash format version for future-proofing
const HASH_VERSION = 'v1';

/**
 * Hash a password using scrypt
 * Format: version:N:r:p:salt:derivedKey (all hex encoded)
 * @param password - Plain text password to hash
 * @returns Hashed password string with embedded parameters
 */
export const encryptPassword = async (password: string): Promise<string> => {
  if (!password.length) {
    throw new Error('Password cannot be empty');
  }
  
  const salt = randomBytes(SALT_LENGTH);
  const derivedKey = (await scryptAsync(
    password, 
    salt, 
    KEY_LENGTH,
    SCRYPT_OPTIONS
  )) as Buffer;
  
  // Embed parameters in hash for future-proof verification
  return [
    HASH_VERSION,
    SCRYPT_OPTIONS.N,
    SCRYPT_OPTIONS.r,
    SCRYPT_OPTIONS.p,
    salt.toString('hex'),
    derivedKey.toString('hex'),
  ].join(':');
};

/**
 * Verify a password against its hash
 * Supports both legacy format (salt:key) and new format (v1:N:r:p:salt:key)
 * @param password - Plain text password to verify
 * @param hash - Previously hashed password
 * @returns True if password matches
 */
export const verifyPassword = async (password: string, hash: string): Promise<boolean> => {
  if (!password || !hash) {
    return false;
  }

  try {
    const parts = hash.split(':');
    
    let salt: Buffer;
    let storedKey: Buffer;
    let options = SCRYPT_OPTIONS;
    
    if (parts[0] === 'v1' && parts.length === 6) {
      // New format: v1:N:r:p:salt:key
      options = {
        N: parseInt(parts[1], 10),
        r: parseInt(parts[2], 10),
        p: parseInt(parts[3], 10),
        maxmem: 256 * 1024 * 1024,
      };
      salt = Buffer.from(parts[4], 'hex');
      storedKey = Buffer.from(parts[5], 'hex');
    } else if (parts.length === 2) {
      // Legacy format: salt:key (uses current options)
      salt = Buffer.from(parts[0], 'hex');
      storedKey = Buffer.from(parts[1], 'hex');
    } else {
      return false;
    }
    
    const derivedKey = (await scryptAsync(
      password, 
      salt, 
      storedKey.length,
      options
    )) as Buffer;
    
    // Constant-time comparison to prevent timing attacks
    return timingSafeEqual(storedKey, derivedKey);
  } catch {
    // Invalid hash format or crypto error
    return false;
  }
};

/**
 * Check if a hash needs to be rehashed (uses old format or weaker settings)
 * @param hash - Existing password hash
 * @returns True if the hash should be regenerated
 */
export const needsRehash = (hash: string): boolean => {
  const parts = hash.split(':');
  
  // Legacy format needs rehash
  if (parts.length === 2) {
    return true;
  }
  
  // Check if current settings are stronger
  if (parts[0] === 'v1' && parts.length === 6) {
    const N = parseInt(parts[1], 10);
    return N < SCRYPT_OPTIONS.N;
  }
  
  return true;
};