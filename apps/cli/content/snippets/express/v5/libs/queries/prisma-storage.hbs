---
name: prisma-storage
description: Generic Storage class for Prisma ORM with CRUD, bulk operations, and pagination
dependencies:
  - "@prisma/client"
devDependencies:
  - prisma
files:
  - name: libs/queries/prisma-storage.ts
---
import { PrismaClient, Prisma } from '@prisma/client';

/**
 * Generic Storage class for Prisma ORM
 * Provides standardized CRUD operations with full type safety
 * 
 * @example
 * import { prisma } from '@/libs/db/prisma';
 * 
 * const userStorage = new PrismaStorage(prisma, 'user');
 * const user = await userStorage.create({ name: 'John', email: 'john@example.com' });
 * const paginatedUsers = await userStorage.paginate({ page: 1, limit: 10 });
 */

export interface PaginationOptions {
  page?: number;
  limit?: number;
  cursor?: string | number;
  cursorField?: string;
  orderBy?: string;
  orderDir?: 'asc' | 'desc';
}

export interface PaginatedResult<T> {
  data: T[];
  pagination: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
    nextCursor?: string | number;
  };
}

export interface FilterOptions {
  where?: Record<string, unknown>;
  include?: Record<string, boolean | object>;
  select?: Record<string, boolean>;
}

export class PrismaStorage<
  TModel extends keyof PrismaClient,
  TCreate = unknown,
  TUpdate = unknown,
  TRecord = unknown
> {
  private model: any;

  constructor(
    private prisma: PrismaClient,
    private modelName: TModel,
    private primaryKey: string = 'id'
  ) {
    this.model = (prisma as any)[modelName];
  }

  /**
   * Create a single record
   */
  async create(data: TCreate, options?: { include?: Record<string, boolean | object> }): Promise<TRecord> {
    return this.model.create({
      data,
      ...options,
    });
  }

  /**
   * Find all records with optional filters
   */
  async findAll(options?: FilterOptions): Promise<TRecord[]> {
    return this.model.findMany({
      where: options?.where,
      include: options?.include,
      select: options?.select,
    });
  }

  /**
   * Find a record by ID
   */
  async findById(
    id: string | number,
    options?: { include?: Record<string, boolean | object> }
  ): Promise<TRecord | null> {
    return this.model.findUnique({
      where: { [this.primaryKey]: id },
      ...options,
    });
  }

  /**
   * Find first record matching filters
   */
  async findOne(
    where: Record<string, unknown>,
    options?: { include?: Record<string, boolean | object> }
  ): Promise<TRecord | null> {
    return this.model.findFirst({
      where,
      ...options,
    });
  }

  /**
   * Update a record by ID
   */
  async update(
    id: string | number,
    data: TUpdate,
    options?: { include?: Record<string, boolean | object> }
  ): Promise<TRecord> {
    return this.model.update({
      where: { [this.primaryKey]: id },
      data,
      ...options,
    });
  }

  /**
   * Hard delete a record by ID
   */
  async delete(id: string | number): Promise<TRecord> {
    return this.model.delete({
      where: { [this.primaryKey]: id },
    });
  }

  /**
   * Soft delete a record (sets deletedAt timestamp)
   * Requires `deletedAt` field in your schema
   */
  async softDelete(id: string | number): Promise<TRecord> {
    return this.model.update({
      where: { [this.primaryKey]: id },
      data: { deletedAt: new Date() },
    });
  }

  /**
   * Restore a soft-deleted record
   */
  async restore(id: string | number): Promise<TRecord> {
    return this.model.update({
      where: { [this.primaryKey]: id },
      data: { deletedAt: null },
    });
  }

  /**
   * Bulk create records using transaction
   */
  async bulkCreate(data: TCreate[]): Promise<TRecord[]> {
    return this.prisma.$transaction(
      data.map((item) => this.model.create({ data: item }))
    );
  }

  /**
   * Bulk update records by IDs
   */
  async bulkUpdate(ids: (string | number)[], data: TUpdate): Promise<{ count: number }> {
    return this.model.updateMany({
      where: { [this.primaryKey]: { in: ids } },
      data,
    });
  }

  /**
   * Bulk delete records by IDs
   */
  async bulkDelete(ids: (string | number)[]): Promise<{ count: number }> {
    return this.model.deleteMany({
      where: { [this.primaryKey]: { in: ids } },
    });
  }

  /**
   * Paginated query with offset or cursor-based pagination
   */
  async paginate(options: PaginationOptions & FilterOptions = {}): Promise<PaginatedResult<TRecord>> {
    const {
      page = 1,
      limit = 10,
      cursor,
      cursorField = this.primaryKey,
      orderBy = this.primaryKey,
      orderDir = 'desc',
      where,
      include,
    } = options;

    // Count total
    const total = await this.model.count({ where });

    // Build query options
    const queryOptions: any = {
      where,
      include,
      orderBy: { [orderBy]: orderDir },
      take: limit,
    };

    // Cursor-based pagination
    if (cursor) {
      queryOptions.cursor = { [cursorField]: cursor };
      queryOptions.skip = 1; // Skip the cursor itself
    } else {
      // Offset-based pagination
      queryOptions.skip = (page - 1) * limit;
    }

    const data = await this.model.findMany(queryOptions);
    const totalPages = Math.ceil(total / limit);
    const nextCursor = data.length > 0 ? data[data.length - 1][cursorField] : undefined;

    return {
      data,
      pagination: {
        total,
        page,
        limit,
        totalPages,
        hasNext: cursor ? data.length === limit : page < totalPages,
        hasPrev: cursor ? !!cursor : page > 1,
        nextCursor,
      },
    };
  }

  /**
   * Count records
   */
  async count(where?: Record<string, unknown>): Promise<number> {
    return this.model.count({ where });
  }

  /**
   * Check if record exists
   */
  async exists(where: Record<string, unknown>): Promise<boolean> {
    const count = await this.model.count({ where });
    return count > 0;
  }

  /**
   * Upsert (create or update)
   */
  async upsert(
    where: Record<string, unknown>,
    create: TCreate,
    update: TUpdate
  ): Promise<TRecord> {
    return this.model.upsert({
      where,
      create,
      update,
    });
  }

  /**
   * Execute operations in a transaction
   */
  async transaction<T>(fn: (tx: Prisma.TransactionClient) => Promise<T>): Promise<T> {
    return this.prisma.$transaction(fn);
  }
}
